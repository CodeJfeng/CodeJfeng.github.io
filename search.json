[{"title":"Java的设计模式实例","path":"/2025/09/11/Java-Design/","content":"学习设计模式的必要性设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。 正确使用设计模式具有以下优点： 可以提高程序员的思维能力、编程能力和设计能力。 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。 设计模式的分类 创建型模型用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。 结构型模式用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。 行为型模式用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。 创建者模式什么是创建者模式？创建型模式的主要关注点是怎样创建对象？，它的主要特点是将对象的创建与使用分离。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。创建型模式分类及详细教程如下： 单例模式单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 单例模式的实现单例设计模式分类两种： 饿汉式： 类加载就会导致该单实例对象被创建 适合在类的实例化代价较小或总是需要使用的情况下使用。 由于在类加载时就创建实例，因此不需要考虑线程安全问题。 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建 在类加载时就实例化对象，不管是否需要使用。 适合在实例化代价较大或不常用的情况下使用。 需要考虑线程安全问题，可能会导致多线程环境下的安全隐患。这两种模式各有优缺点，选择时需根据具体情况而定。 饿汉式-方式1 (静态变量方式)静态变量创建类的对象 public class Singleton //私有构造方法 private Singleton() ​ //在成员位置创建该类的对象 private static Singleton instance = new Singleton();​ //对外提供静态方法获取该对象 public static Singleton getInstance() return instance; 说明该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。 饿汉式-方式2 (静态代码块方式)静态代码块中创建类的对象 public class Singleton ​ //私有构造方法 private Singleton() ​ //在成员位置创建该类的对象 private static Singleton instance;​ static instance = new Singleton(); ​ //对外提供静态方法获取该对象 public static Singleton getInstance() return instance; 说明该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。 懒汉方式1–线程不安全/** * 懒汉式 * 线程不安全 */public class Singleton //私有构造方法 private Singleton() ​ //在成员位置创建该类的对象 private static Singleton instance;​ //对外提供静态方法获取该对象 public static Singleton getInstance() ​ if(instance == null) instance = new Singleton(); return instance; 说明从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。 解释下为什么会存在线程问题：假设现在有两个线程t1和t2同时调用getInstance() 方法，t1刚判断instance null为true进入内部吗，刚要进行创建，此时正好丢失CPU执行权，进入阻塞状态，而t2获得CPU执行权，也进行了instance null判断，发现也是true，就进入了内部代码进行创建，此时我们发现t1和t2都会执行内部的new代码，从而获得了两个不同的实例对象。 懒汉方式2–线程安全/** * 懒汉式 * 线程安全 */public class Singleton //私有构造方法 private Singleton() ​ //在成员位置创建该类的对象 private static Singleton instance;​ //对外提供静态方法获取该对象 public static synchronized Singleton getInstance() ​ if(instance == null) instance = new Singleton(); return instance; 说明该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。 懒汉式-方式3（双重检查锁）再来讨论一下懒汉模式中加锁的问题，对于 getInstance() 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式 /** * 双重检查方式 */public class Singleton ​ //私有构造方法 private Singleton() ​ private static Singleton instance;​ //对外提供静态方法获取该对象 public static Singleton getInstance() //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例 if(instance == null) synchronized (Singleton.class) //抢到锁之后再次判断是否为null if(instance == null) instance = new Singleton(); return instance; 双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。 要解决双重检查锁模式带来空指针异常的问题，只需要使用volatile关键字, volatile关键字可以保证可见性和有序性。在单例模式中，volatile关键字主要用于确保多线程环境下的可见性和禁止指令重排序。当一个类使用懒汉式的方式创建单例对象时，volatile 可以防止由于指令重排序导致的问题。通过使用volatile关键字，可以保证在多线程环境下对 instance 的可见性和防止指令重排序： /** 使用 volatile 防止指令重排 */public class Singleton private static volatile Singleton instance; private Singleton() public static Singleton getInstance() if (instance == null) synchronized (Singleton.class) if (instance == null) instance = new Singleton(); return instance; 在上面的代码中，将 instance 声明为 volatile 可以确保在一个线程修改了 instance 的值后，其他线程能够立即看到这个变化，避免了由于指令重排序而导致的问题。 这种方式通常称为双重检查锁定（Double-Checked Locking）机制，通过在内部的 if (instance null) 判断之前和之后都进行一次检查，以保证线程安全且效率较高。需要注意的是，这种方式要求 instance 被声明为 volatile。 小结添加volatile关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。 懒汉式-方式4（静态内部类方式）静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被static修饰，保证只被实例化一次，并且严格保证实例化顺序。 /** * 静态内部类方式 */public class Singleton ​ //私有构造方法 private Singleton() ​ private static class SingletonHolder private static final Singleton INSTANCE = new Singleton(); ​ //对外提供静态方法获取该对象 public static Singleton getInstance() return SingletonHolder.INSTANCE; 说明第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder 小结静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。 枚举方式枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。 /** * 枚举方式 */public enum Singleton INSTANCE; 枚举方式属于饿汉式方式。 两种破坏单例模式的场景及如何防止的代码演示前面我们演示了单例模式的多种Java代码的实现方式，虽然看上去完美无缺的，但是其实还是存在一定的问题的，在某些场景下，可以破坏单例模式，从而创建出来多个实例。接下来，我们一起看下破坏单例模式的两个场景，以及每个场景我们应该如何预防被破坏。 破坏单例模式两种场景使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。 序列化反序列化方式破坏单例模式演示Singleton类：(内部静态类构造单例对象) public class Singleton implements Serializable ​ //私有构造方法 -- 内部静态类 private Singleton() ​ private static class SingletonHolder private static final Singleton INSTANCE = new Singleton(); ​ //对外提供静态方法获取该对象 public static Singleton getInstance() return SingletonHolder.INSTANCE; Test类： public class Test public static void main(String[] args) throws Exception //往文件中写对象 //writeObject2File(); //从文件中读取对象 Singleton s1 = readObjectFromFile(); Singleton s2 = readObjectFromFile();​ //判断两个反序列化后的对象是否是同一个对象 System.out.println(s1 == s2); ​ private static Singleton readObjectFromFile() throws Exception //创建对象输入流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(C:\\\\Users\\\\Think\\\\Desktop\\\\a.txt)); //第一个读取Singleton对象 Singleton instance = (Singleton) ois.readObject();​ return instance; ​ public static void writeObject2File() throws Exception //获取Singleton类的对象 Singleton instance = Singleton.getInstance(); //创建对象输出流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(C:\\\\Users\\\\Think\\\\Desktop\\\\a.txt)); //将instance对象写出到文件中 oos.writeObject(instance); 上面代码运行结果是false，表明序列化和反序列化已经破坏了单例设计模式。 反射方式破坏单例模式演示Singleton类： public class Singleton ​ //私有构造方法 private Singleton() private static volatile Singleton instance;​ //对外提供静态方法获取该对象 -- 双重检查锁 public static Singleton getInstance() ​ if(instance != null) return instance; ​ synchronized (Singleton.class) if(instance != null) return instance; instance = new Singleton(); return instance; Test类： public class Test public static void main(String[] args) throws Exception //获取Singleton类的字节码对象 Class clazz = Singleton.class; //获取Singleton类的私有无参构造方法对象 Constructor constructor = clazz.getDeclaredConstructor(); //取消访问检查 constructor.setAccessible(true);​ //创建Singleton类的对象s1 Singleton s1 = (Singleton) constructor.newInstance(); //创建Singleton类的对象s2 Singleton s2 = (Singleton) constructor.newInstance();​ //判断通过反射创建的两个Singleton对象是否是同一个对象 System.out.println(s1 == s2); 说明反射通过 setAccessible(true) 把 private 构造方法“撬开”，再绕过 JVM 的访问检查直接 new 实例，因此完全无视你写的单例逻辑。上面代码运行结果是false，表明序列化和反序列化已经破坏了单例设计模式 注意：枚举方式实现的单例模式不会出现这两个问题。 如何解决破坏单例的问题在Singleton类中添加readResolve()方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。 序列化、反序列方式破坏单例模式的解决方法在Singleton类中添加readResolve()方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。Singleton类： public class Singleton implements Serializable ​ //私有构造方法 private Singleton() ​ private static class SingletonHolder private static final Singleton INSTANCE = new Singleton(); ​ //对外提供静态方法获取该对象 public static Singleton getInstance() return SingletonHolder.INSTANCE; /** * 下面是为了解决序列化反序列化破解单例模式 */ private Object readResolve() return SingletonHolder.INSTANCE; 源码解析：ObjectInputStream类： public final Object readObject() throws IOException, ClassNotFoundException ... // if nested read, passHandle contains handle of enclosing object int outerHandle = passHandle; try Object obj = readObject0(false);//重点查看readObject0方法 ..... private Object readObject0(boolean unshared) throws IOException ... try switch (tc) ... case TC_OBJECT: return checkResolve(readOrdinaryObject(unshared));//重点查看readOrdinaryObject方法 ... finally depth--; bin.setBlockDataMode(oldMode); private Object readOrdinaryObject(boolean unshared) throws IOException ... //isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类， obj = desc.isInstantiable() ? desc.newInstance() : null; ... // 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true if (obj != null handles.lookupException(passHandle) == null desc.hasReadResolveMethod()) // 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量 // 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。 Object rep = desc.invokeReadResolve(obj); ... return obj; 数据流向：readObject() → readObject0() → readOrdinaryObject() 目的是把磁盘里的字节流还原成 Java 对象。 desc.isInstantiable() ? desc.newInstance() : null; desc 是类描述符（ObjectStreamClass）。 isInstantiable() 只要你的类不是 enum 且有无参构造就返回 true。 newInstance() 通过反射 Constructor.newInstance() 强行 new 一个新对象，完全绕过构造方法里的单例检查。 这一步就解释了为什么不加 readResolve() 时单例会被破坏——每次反序列化都 new 一个。 desc.hasReadResolveMethod() 如果你在类里写了readResolve(),这里就会返回 true。小结Java 反序列化时，如果目标类里写了 readResolve()，就先用反射“new”出一个新实例，再立刻调用你的 readResolve() 把那个新实例“掉包”成你指定的单例，最后把单例返回给使用者。 反射方式破解单例的解决方法public class Singleton ​ //私有构造方法 private Singleton() /* 反射破解单例模式需要添加的代码 */ if(instance != null) // 第一次反射进来时 instance 为 null，拦不住； // 但第二次反射再进来时 instance 已非 null，可抛出异常阻止 throw new RuntimeException(); private static volatile Singleton instance;​ //对外提供静态方法获取该对象 public static Singleton getInstance() ​ // if(instance != null) return instance; ​ synchronized (Singleton.class) if(instance != null) return instance; instance = new Singleton(); return instance; 说明这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操作。 注意：这种写法只能挡第二次及以后的反射；完全杜绝还是得用枚举。","tags":["Java基础","设计开发"],"categories":["Java","设计开发"]},{"title":"Hello World","path":"/2025/09/08/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment 测试目录1测试目录2测试目录3测试目录4测试目录1测试目录1测试目录1测试目录1测试目录1测试目录1"}]