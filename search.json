[{"title":"Spring-Base","path":"/2025/09/13/Spring-Base/","content":"Spring 基础框架Spring 概述Spring是分层的Java SEEE应用full-stack轻量级开源框架,以**IoC ( Inverse Of Control:反转控制)和AOP (Aspect oriented Progr anming:面向切面编程)**为内核，提供了展现层SpringMVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。 Spring 优势 方便解耦，简化开发通过Spring提供的IoC容器,可以将对象间的依赖关系交由Spring 进行控制,避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 AOP编程的支持通过Spring的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。 声明式事务的支持可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。 方便程序的测试可以非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。 方便集成各种优秀框架Spring可以降低各种框架的使用难度,提供了对各种优秀框架(Struts、Hibernate. Hessian、Quartz等)的直接支持。 降低JavaEE API的使用难度Spring对JavaEE API (如JDBC、JavaMail、远程调用等)进行了薄薄的封装层，使这些API的使用难度大为降低。 Java源码是经典学习范例Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无疑是Java技术的最佳实践的范例","tags":["java","Spring"]},{"title":"Java的设计模式实例","path":"/2025/09/11/Java-Design/","content":"学习设计模式的必要性设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。 正确使用设计模式具有以下优点： 可以提高程序员的思维能力、编程能力和设计能力。 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。 设计模式的分类 创建型模型用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。 结构型模式用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。 行为型模式用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。 创建者模式什么是创建者模式？创建型模式的主要关注点是怎样创建对象？，它的主要特点是将对象的创建与使用分离。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。创建型模式分类及详细教程如下： 单例模式单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 单例模式的实现单例设计模式分类两种： 饿汉式： 类加载就会导致该单实例对象被创建 适合在类的实例化代价较小或总是需要使用的情况下使用。 由于在类加载时就创建实例，因此不需要考虑线程安全问题。 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建 在类加载时就实例化对象，不管是否需要使用。 适合在实例化代价较大或不常用的情况下使用。 需要考虑线程安全问题，可能会导致多线程环境下的安全隐患。这两种模式各有优缺点，选择时需根据具体情况而定。 饿汉式-方式1 (静态变量方式)静态变量创建类的对象 public class Singleton //私有构造方法 private Singleton() ​ //在成员位置创建该类的对象 private static Singleton instance = new Singleton();​ //对外提供静态方法获取该对象 public static Singleton getInstance() return instance; 说明该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。 饿汉式-方式2 (静态代码块方式)静态代码块中创建类的对象 public class Singleton ​ //私有构造方法 private Singleton() ​ //在成员位置创建该类的对象 private static Singleton instance;​ static instance = new Singleton(); ​ //对外提供静态方法获取该对象 public static Singleton getInstance() return instance; 说明该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。 懒汉方式1–线程不安全/** * 懒汉式 * 线程不安全 */public class Singleton //私有构造方法 private Singleton() ​ //在成员位置创建该类的对象 private static Singleton instance;​ //对外提供静态方法获取该对象 public static Singleton getInstance() ​ if(instance == null) instance = new Singleton(); return instance; 说明从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。 解释下为什么会存在线程问题：假设现在有两个线程t1和t2同时调用getInstance() 方法，t1刚判断instance null为true进入内部吗，刚要进行创建，此时正好丢失CPU执行权，进入阻塞状态，而t2获得CPU执行权，也进行了instance null判断，发现也是true，就进入了内部代码进行创建，此时我们发现t1和t2都会执行内部的new代码，从而获得了两个不同的实例对象。 懒汉方式2–线程安全/** * 懒汉式 * 线程安全 */public class Singleton //私有构造方法 private Singleton() ​ //在成员位置创建该类的对象 private static Singleton instance;​ //对外提供静态方法获取该对象 public static synchronized Singleton getInstance() ​ if(instance == null) instance = new Singleton(); return instance; 说明该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。 懒汉式-方式3（双重检查锁）再来讨论一下懒汉模式中加锁的问题，对于 getInstance() 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式 /** * 双重检查方式 */public class Singleton ​ //私有构造方法 private Singleton() ​ private static Singleton instance;​ //对外提供静态方法获取该对象 public static Singleton getInstance() //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例 if(instance == null) synchronized (Singleton.class) //抢到锁之后再次判断是否为null if(instance == null) instance = new Singleton(); return instance; 双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。 要解决双重检查锁模式带来空指针异常的问题，只需要使用volatile关键字, volatile关键字可以保证可见性和有序性。在单例模式中，volatile关键字主要用于确保多线程环境下的可见性和禁止指令重排序。当一个类使用懒汉式的方式创建单例对象时，volatile 可以防止由于指令重排序导致的问题。通过使用volatile关键字，可以保证在多线程环境下对 instance 的可见性和防止指令重排序： /** 使用 volatile 防止指令重排 */public class Singleton private static volatile Singleton instance; private Singleton() public static Singleton getInstance() if (instance == null) synchronized (Singleton.class) if (instance == null) instance = new Singleton(); return instance; 在上面的代码中，将 instance 声明为 volatile 可以确保在一个线程修改了 instance 的值后，其他线程能够立即看到这个变化，避免了由于指令重排序而导致的问题。 这种方式通常称为双重检查锁定（Double-Checked Locking）机制，通过在内部的 if (instance null) 判断之前和之后都进行一次检查，以保证线程安全且效率较高。需要注意的是，这种方式要求 instance 被声明为 volatile。 小结添加volatile关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。 懒汉式-方式4（静态内部类方式）静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被static修饰，保证只被实例化一次，并且严格保证实例化顺序。 /** * 静态内部类方式 */public class Singleton ​ //私有构造方法 private Singleton() ​ private static class SingletonHolder private static final Singleton INSTANCE = new Singleton(); ​ //对外提供静态方法获取该对象 public static Singleton getInstance() return SingletonHolder.INSTANCE; 说明第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder 小结静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。 枚举方式枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。 /** * 枚举方式 */public enum Singleton INSTANCE; 枚举方式属于饿汉式方式。 两种破坏单例模式的场景及如何防止的代码演示前面我们演示了单例模式的多种Java代码的实现方式，虽然看上去完美无缺的，但是其实还是存在一定的问题的，在某些场景下，可以破坏单例模式，从而创建出来多个实例。接下来，我们一起看下破坏单例模式的两个场景，以及每个场景我们应该如何预防被破坏。 破坏单例模式两种场景使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。 序列化反序列化方式破坏单例模式演示Singleton类：(内部静态类构造单例对象) public class Singleton implements Serializable ​ //私有构造方法 -- 内部静态类 private Singleton() ​ private static class SingletonHolder private static final Singleton INSTANCE = new Singleton(); ​ //对外提供静态方法获取该对象 public static Singleton getInstance() return SingletonHolder.INSTANCE; Test类： public class Test public static void main(String[] args) throws Exception //往文件中写对象 //writeObject2File(); //从文件中读取对象 Singleton s1 = readObjectFromFile(); Singleton s2 = readObjectFromFile();​ //判断两个反序列化后的对象是否是同一个对象 System.out.println(s1 == s2); ​ private static Singleton readObjectFromFile() throws Exception //创建对象输入流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(C:\\\\Users\\\\Think\\\\Desktop\\\\a.txt)); //第一个读取Singleton对象 Singleton instance = (Singleton) ois.readObject();​ return instance; ​ public static void writeObject2File() throws Exception //获取Singleton类的对象 Singleton instance = Singleton.getInstance(); //创建对象输出流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(C:\\\\Users\\\\Think\\\\Desktop\\\\a.txt)); //将instance对象写出到文件中 oos.writeObject(instance); 上面代码运行结果是false，表明序列化和反序列化已经破坏了单例设计模式。 反射方式破坏单例模式演示Singleton类： public class Singleton ​ //私有构造方法 private Singleton() private static volatile Singleton instance;​ //对外提供静态方法获取该对象 -- 双重检查锁 public static Singleton getInstance() ​ if(instance != null) return instance; ​ synchronized (Singleton.class) if(instance != null) return instance; instance = new Singleton(); return instance; Test类： public class Test public static void main(String[] args) throws Exception //获取Singleton类的字节码对象 Class clazz = Singleton.class; //获取Singleton类的私有无参构造方法对象 Constructor constructor = clazz.getDeclaredConstructor(); //取消访问检查 constructor.setAccessible(true);​ //创建Singleton类的对象s1 Singleton s1 = (Singleton) constructor.newInstance(); //创建Singleton类的对象s2 Singleton s2 = (Singleton) constructor.newInstance();​ //判断通过反射创建的两个Singleton对象是否是同一个对象 System.out.println(s1 == s2); 说明反射通过 setAccessible(true) 把 private 构造方法“撬开”，再绕过 JVM 的访问检查直接 new 实例，因此完全无视你写的单例逻辑。上面代码运行结果是false，表明序列化和反序列化已经破坏了单例设计模式 注意：枚举方式实现的单例模式不会出现这两个问题。 如何解决破坏单例的问题在Singleton类中添加readResolve()方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。 序列化、反序列方式破坏单例模式的解决方法在Singleton类中添加readResolve()方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。Singleton类： public class Singleton implements Serializable ​ //私有构造方法 private Singleton() ​ private static class SingletonHolder private static final Singleton INSTANCE = new Singleton(); ​ //对外提供静态方法获取该对象 public static Singleton getInstance() return SingletonHolder.INSTANCE; /** * 下面是为了解决序列化反序列化破解单例模式 */ private Object readResolve() return SingletonHolder.INSTANCE; 源码解析：ObjectInputStream类： public final Object readObject() throws IOException, ClassNotFoundException ... // if nested read, passHandle contains handle of enclosing object int outerHandle = passHandle; try Object obj = readObject0(false);//重点查看readObject0方法 ..... private Object readObject0(boolean unshared) throws IOException ... try switch (tc) ... case TC_OBJECT: return checkResolve(readOrdinaryObject(unshared));//重点查看readOrdinaryObject方法 ... finally depth--; bin.setBlockDataMode(oldMode); private Object readOrdinaryObject(boolean unshared) throws IOException ... //isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类， obj = desc.isInstantiable() ? desc.newInstance() : null; ... // 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true if (obj != null handles.lookupException(passHandle) == null desc.hasReadResolveMethod()) // 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量 // 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。 Object rep = desc.invokeReadResolve(obj); ... return obj; 数据流向：readObject() → readObject0() → readOrdinaryObject() 目的是把磁盘里的字节流还原成 Java 对象。 desc.isInstantiable() ? desc.newInstance() : null; desc 是类描述符（ObjectStreamClass）。 isInstantiable() 只要你的类不是 enum 且有无参构造就返回 true。 newInstance() 通过反射 Constructor.newInstance() 强行 new 一个新对象，完全绕过构造方法里的单例检查。 这一步就解释了为什么不加 readResolve() 时单例会被破坏——每次反序列化都 new 一个。 desc.hasReadResolveMethod() 如果你在类里写了readResolve(),这里就会返回 true。 小结Java 反序列化时，如果目标类里写了 readResolve()，就先用反射“new”出一个新实例，再立刻调用你的 readResolve() 把那个新实例“掉包”成你指定的单例，最后把单例返回给使用者。 反射方式破解单例的解决方法public class Singleton ​ //私有构造方法 private Singleton() /* 反射破解单例模式需要添加的代码 */ if(instance != null) // 第一次反射进来时 instance 为 null，拦不住； // 但第二次反射再进来时 instance 已非 null，可抛出异常阻止 throw new RuntimeException(); private static volatile Singleton instance;​ //对外提供静态方法获取该对象 public static Singleton getInstance() ​ // if(instance != null) return instance; ​ synchronized (Singleton.class) if(instance != null) return instance; instance = new Singleton(); return instance; 说明这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操作。 注意：这种写法只能挡第二次及以后的反射；完全杜绝还是得用枚举。 工厂模式假设设计一个咖啡店点餐系统设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。 具体类的设计如下： 概念在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：解耦。结构本章中会介绍三种工厂的使用： 简单工厂模式（不属于GOF的23种经典设计模式） 工厂方法模式 抽象工厂模式 简单工厂模式简单工厂不是一种设计模式，反而比较像是一种编程习惯。 简单工厂包含如下角色： 具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。 抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。 具体产品 ：实现或者继承抽象产品的子类 现在使用简单工厂对上面案例进行改进，类图如下： 工厂类代码如下： public class SimpleCoffeeFactory ​ public Coffee createCoffee(String type) Coffee coffee = null; if(americano.equals(type)) coffee = new AmericanoCoffee(); else if(latte.equals(type)) coffee = new LatteCoffee(); return coffee; 工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。 后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。 优缺点优点封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。缺点增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。 静态工厂模式在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下： public class SimpleCoffeeFactory ​ public static Coffee createCoffee(String type) Coffee coffee = null; if(americano.equals(type)) coffee = new AmericanoCoffee(); else if(latte.equals(type)) coffee = new LatteCoffee(); return coffe; 工厂方法模式针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。概念定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。结构工厂方法模式的主要角色： 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。实现代码如下：抽象工厂: public interface CoffeeFactory ​ Coffee createCoffee(); 具体工厂： public class LatteCoffeeFactory implements CoffeeFactory public Coffee createCoffee() return new LatteCoffee(); ​public class AmericanCoffeeFactory implements CoffeeFactory ​ public Coffee createCoffee() return new AmericanCoffee(); 咖啡店类： public class CoffeeStore ​ private CoffeeFactory factory;​ public CoffeeStore(CoffeeFactory factory) this.factory = factory; ​ public Coffee orderCoffee(String type) Coffee coffee = factory.createCoffee(); coffee.addMilk(); coffee.addsugar(); return coffee; 从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。 工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。 优缺点优点： 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程； 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；缺点： 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。 抽象工厂模式前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机等。这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。 概念抽象工厂模式是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。 结构抽象工厂模式的主要角色如下： 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。 实现现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：代码如下：抽象工厂类： public interface DessertFactory ​ Coffee createCoffee();​ Dessert createDessert(); 具体工厂类： //美式甜点工厂public class AmericanDessertFactory implements DessertFactory ​ public Coffee createCoffee() return new AmericanCoffee(); ​ public Dessert createDessert() return new MatchaMousse(); //意大利风味甜点工厂public class ItalyDessertFactory implements DessertFactory ​ public Coffee createCoffee() return new LatteCoffee(); ​ public Dessert createDessert() return new Tiramisu(); 优缺点优点当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。缺点当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。使用场景当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。 模式扩展简单工厂+配置文件解除耦合可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。第一步：定义配置文件为了演示方便，我们使用properties文件作为配置文件，名称为bean.properties american=com.itheima.pattern.factory.config_factory.AmericanCoffeelatte=com.itheima.pattern.factory.config_factory.LatteCoffee 第二步：改进工厂类 public class CoffeeFactory ​ private static MapString, Coffee map = new HashMap();​ static Properties p = new Properties(); InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(bean.properties); try p.load(is); //遍历Properties集合对象 SetObject keys = p.keySet(); for (Object key : keys) //根据键获取值（全类名） String className = p.getProperty((String) key); //获取字节码对象 Class clazz = Class.forName(className); Coffee obj = (Coffee) clazz.newInstance(); map.put((String)key,obj); catch (Exception e) e.printStackTrace(); ​ public static Coffee createCoffee(String name) ​ return map.get(name); 静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。 源码解析-Collection.Iterator方法public class Demo public static void main(String[] args) ListString list = new ArrayList(); list.add(1); list.add(2); list.add(2);​ //获取迭代器对象 IteratorString it = list.iterator(); //使用迭代器遍历 while(it.hasNext()) String ele = it.next(); System.out.println(ele); 使用迭代器遍历集合，获取集合中的元素。而单列集合获取迭代器的方法就使用到了工厂方法模式。我们看通过类图看看结构：Collection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。在具体的工厂类中iterator()方法创建具体的商品类的对象。 原型模式概述所谓原型模式，即：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。结构原型模式包含如下角色： 抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。 访问类：使用具体原型类中的 clone() 方法来复制新的对象。接口类图如下","tags":["Java基础","设计开发"],"categories":["Java","设计开发"]},{"title":"Hello World","path":"/2025/09/08/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment 测试目录1测试目录2测试目录3测试目录4测试目录1测试目录1测试目录1测试目录1测试目录1测试目录1"}]