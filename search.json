[{"title":"Java的设计模式实例","path":"/2025/09/11/Java-Design/","content":"学习设计模式的必要性设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。 正确使用设计模式具有以下优点： 可以提高程序员的思维能力、编程能力和设计能力。 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。 设计模式的分类 创建型模型用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。 结构型模式用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。 行为型模式用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。 创建者模式什么是创建者模式？创建型模式的主要关注点是怎样创建对象？，它的主要特点是将对象的创建与使用分离。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。创建型模式分类及详细教程如下： 单例模式单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 单例模式的实现单例设计模式分类两种： 饿汉式： 类加载就会导致该单实例对象被创建 适合在类的实例化代价较小或总是需要使用的情况下使用。 由于在类加载时就创建实例，因此不需要考虑线程安全问题。 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建 在类加载时就实例化对象，不管是否需要使用。 适合在实例化代价较大或不常用的情况下使用。 需要考虑线程安全问题，可能会导致多线程环境下的安全隐患。这两种模式各有优缺点，选择时需根据具体情况而定。 饿汉式-方式1 (静态变量方式)静态变量创建类的对象 public class Singleton //私有构造方法 private Singleton() ​ //在成员位置创建该类的对象 private static Singleton instance = new Singleton();​ //对外提供静态方法获取该对象 public static Singleton getInstance() return instance; 说明该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。 饿汉式-方式2 (静态代码块方式)静态代码块中创建类的对象 public class Singleton ​ //私有构造方法 private Singleton() ​ //在成员位置创建该类的对象 private static Singleton instance;​ static instance = new Singleton(); ​ //对外提供静态方法获取该对象 public static Singleton getInstance() return instance; 说明该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。 懒汉方式1–线程不安全/** * 懒汉式 * 线程不安全 */public class Singleton //私有构造方法 private Singleton() ​ //在成员位置创建该类的对象 private static Singleton instance;​ //对外提供静态方法获取该对象 public static Singleton getInstance() ​ if(instance == null) instance = new Singleton(); return instance; 说明从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。 解释下为什么会存在线程问题：假设现在有两个线程t1和t2同时调用getInstance() 方法，t1刚判断instance null为true进入内部吗，刚要进行创建，此时正好丢失CPU执行权，进入阻塞状态，而t2获得CPU执行权，也进行了instance null判断，发现也是true，就进入了内部代码进行创建，此时我们发现t1和t2都会执行内部的new代码，从而获得了两个不同的实例对象。 懒汉方式2–线程安全/** * 懒汉式 * 线程安全 */public class Singleton //私有构造方法 private Singleton() ​ //在成员位置创建该类的对象 private static Singleton instance;​ //对外提供静态方法获取该对象 public static synchronized Singleton getInstance() ​ if(instance == null) instance = new Singleton(); return instance; 说明该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。 懒汉式-方式3（双重检查锁）再来讨论一下懒汉模式中加锁的问题，对于 getInstance() 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式 /** * 双重检查方式 */public class Singleton ​ //私有构造方法 private Singleton() ​ private static Singleton instance;​ //对外提供静态方法获取该对象 public static Singleton getInstance() //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例 if(instance == null) synchronized (Singleton.class) //抢到锁之后再次判断是否为null if(instance == null) instance = new Singleton(); return instance; 双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。 要解决双重检查锁模式带来空指针异常的问题，只需要使用volatile关键字, volatile关键字可以保证可见性和有序性。在单例模式中，volatile关键字主要用于确保多线程环境下的可见性和禁止指令重排序。当一个类使用懒汉式的方式创建单例对象时，volatile 可以防止由于指令重排序导致的问题。通过使用volatile关键字，可以保证在多线程环境下对 instance 的可见性和防止指令重排序： /** 使用 volatile 防止指令重排 */public class Singleton private static volatile Singleton instance; private Singleton() public static Singleton getInstance() if (instance == null) synchronized (Singleton.class) if (instance == null) instance = new Singleton(); return instance; 在上面的代码中，将 instance 声明为 volatile 可以确保在一个线程修改了 instance 的值后，其他线程能够立即看到这个变化，避免了由于指令重排序而导致的问题。 这种方式通常称为双重检查锁定（Double-Checked Locking）机制，通过在内部的 if (instance null) 判断之前和之后都进行一次检查，以保证线程安全且效率较高。需要注意的是，这种方式要求 instance 被声明为 volatile。 小结添加volatile关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。 懒汉式-方式4（静态内部类方式）静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被static修饰，保证只被实例化一次，并且严格保证实例化顺序。 /** * 静态内部类方式 */public class Singleton ​ //私有构造方法 private Singleton() ​ private static class SingletonHolder private static final Singleton INSTANCE = new Singleton(); ​ //对外提供静态方法获取该对象 public static Singleton getInstance() return SingletonHolder.INSTANCE; 说明第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder 小结静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。 枚举方式枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。 /** * 枚举方式 */public enum Singleton INSTANCE; 枚举方式属于饿汉式方式。","tags":["Java基础","设计开发"],"categories":["Java","设计开发"]},{"title":"Hello World","path":"/2025/09/08/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment 测试目录1测试目录2测试目录3测试目录4测试目录1测试目录1测试目录1测试目录1测试目录1测试目录1"}]