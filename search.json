[{"title":"Java多线程高级","path":"/2025/09/26/Java-Thread-enchance/","content":"第一章 线程同步（Synchronize锁，volatile）1.1 线程同步机制线程同步机制是一套用于协调线程之间的数据访问的机制。该机制可以保障线程安全。Java平台提供的线程同步机制包括：锁、volatile关键字、final关键字、static关键字、以及相应的API（如Object.wait()Object.notify()）等。 1.2 锁概述线程安全问题的产生前提是多个线程并发访问共享数据。所以我们将多个线程对共享数据的并发访问转换为串行访问，即一个共享数据一次只能被一个线程访问。锁就是复用这种思路来保障线程安全的。 锁可以理解为对共享数据进行保护的许可证。如果想要访问这些共享数据，就必须先持有该许可证。而许可证一次只能被一个线程持有，且访问完共享数据后，需要释放其持有的许可证。 线程持有锁后，直到释放锁为止执行的代码，我们称为临界区（Critical Section）。 JVM把锁分为内部锁和显示锁两种。内部锁通过synchronized关键字实现，显示锁通过java.concurrent.locks.Lock接口的实现类来实现。 1.2.1 锁的作用 锁可以实现对共享数据的安全访问，保障线程的原子性、可见性和有序性。 锁通过互斥保障原子性。一个锁只能被一个线程持有，这就保证临界区的代码一次只能被一个线程执行，使得临界区代码所执行的操作自然而然地具有不可分割的特性，具备了原子性。 可见性的保障是通过写线程冲刷处理器的缓存和读线程刷新处理器缓存这两个动作实现的。在Java平台中，锁的获得隐含着刷新处理器缓存的动作，锁的释放隐含着冲刷处理器缓存的动作。 锁能够保障有序性。 注意：使用锁保障线程的安全性，必须满足以下条件：这些线程在访问共享数据时，必须使用同一个把锁，当然读也是需要是同一把锁的。 1.2.2 锁相关的概念 可重入性（Reentrancy）：当一个线程持有该锁的时候，能够再次申请并获得该锁； 锁的争用与调度：Java平台中内部锁属于非公平锁，而显示Lock接口锁支持公平锁非公平锁； 锁的粒度：一个锁可以保护的共享数据的数量大小称为锁的粒度。保护的共享数据量大，称该锁的粒度粗，否则称该锁的粒度细。锁的粒度过大会造成申请锁时不必要的等待，锁的力度过细会增加锁调度的开销； Java中的每个对象都有一个与之关联的内部锁（Intrinsic lock），这种锁也称为监视器（Monitor），它是一种排它锁，可以保障原子性、可见性和有序性。 内部锁是通过synchronized关键字实现的。synchronized关键字可以修饰类、方法、代码块 修饰一个类：其作用的范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象； 修饰一个方法：被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 修饰一个静态方法：其作用的范围是整个方法，作用的对象是这个类的所有对象； 修饰一个代码块：被修饰的代码块称为同步语句块，其作用范围是大括号{}括起来的代码块，作用的对象是调用这个代码块的对象； 1.2.3 synchronized同步代码块通常使用this当前对象作为锁对象 public class Test01 public static void main(String[] args) //创建两个线程，分别调用mm()方法 //先创建Test01对象，通过对象名调用mm() Test01 obj = new Test01(); new Thread(new Runnable() @Override public void run() obj.mm(); , Thread1).start(); new Thread(new Runnable() @Override public void run() obj.mm(); , Thread2).start(); //定义方法 public void mm() synchronized (this) //通常使用this当前对象作为锁对象 for(int i = 1; i = 100; i++) System.out.println(Thread.currentThread().getName() + -- + i); 通过synchronized关键字，在执行代码块的时候会获取该对象的锁，所以线程2必须要等线程1打印完后释放了锁才能获取到锁并执行代码块。所以可以看到，先是线程1的打印信息，再才是线程2的打印信息。 1.2.4 也可对指向常量的对象进行上锁public class Test01 public static final Object OBJ = new Object(); public static void main(String[] args) ... //定义方法 public void mm() synchronized (OBJ) for(int i = 1; i = 100; i++) System.out.println(Thread.currentThread().getName() + -- + i); 当锁住静态代码块或者静态方法时，锁的是类，可以简单理解为将字节码文件进行了上锁。有的时候也称这把锁为类锁。 1.2.5 同步代码块和同步方法如何选择：public void mm() throws InterruptedException System.out.println(任务开始); TimeUnit.MILLISECONDS.sleep(500); //任务准备工作 synchronized (this) for(int i = 0; i = 10; i++) System.out.println(Thread.currentThread().getName() + : + i); 像上面这样的方法，显然如果写成同步方法的话，那么准备任务的时候也获得了锁，这是不好的。所以像上面这样的方法，写成同步代码块比较好。 简而言之：同步方法的粒度粗，并发效率低。同步代码块的粒度细，并发效率高。 1.2.6 脏读public class Test05 public static void main(String[] args) SharedValue sharedValue = new SharedValue(); new Thread(new Runnable() @Override public void run() try sharedValue.setValue(chenxin, 456); catch (InterruptedException e) e.printStackTrace(); , Thread1).start(); new Thread(new Runnable() @Override public void run() sharedValue.readValue(); , Thread2).start(); static class SharedValue String username = xiaoxin; String password = 123; public void setValue(String username, String password) throws InterruptedException this.username = username; TimeUnit.SECONDS.sleep(1); this.password = password; public void readValue() System.out.println(username: + username); System.out.println(password: + password); 出现脏读的原因：对共享数据的修改与对共享数据的读取不同步。 1.2.7 线程出现异常会自动释放内部锁public class Test04 public static void main(String[] args) new Thread(new Runnable() @Override public void run() Test04.m1(); , Thread1).start(); new Thread(new Runnable() @Override public void run() new Test04().m2(); , Thread2).start(); public synchronized static void m1() for(int i = 0; i 100; i++) System.out.println(Thread.currentThread().getName() + : + i); if(i == 50) i = Integer.parseInt(abc); //产生异常 public void m2() synchronized (Test04.class) for(int i = 0; i 100; i++) System.out.println(Thread.currentThread().getName() + : + i); 可以发现，Thread1打印到50的时候，Thread2开始打印。说明，异常会释放锁，所以Thread2才能获得锁去执行。 1.2.8 死锁死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。 1.3 轻量级同步机制：volatile关键字1.3.1 volatile的作用使变量在多个线程之间可见。当volatile关键字修饰的变量被改变时，会强制将其值刷新到主存中，并且，如果有其他处理器的缓存保存了该主存地址的值的话，会强制将其值刷新到别的处理器的缓存中。 1.3.2 volatile和synchronized的区别： volatile是线程同步的轻量级实现，所以volatile的性能肯定比synchronized要好； volatile只能修饰变量，而synchronized还可以修饰方法、代码块、类； 多线程访问volatile变量不会发生阻塞，而synchronized可能会发生阻塞； volatile能保证数据的可见性，但是不能保证原子性而synchronized两者都可以保障； volatile解决的是变量在多个线程之间的可见性问题，而synchronized解决的是多个线程在访问资源时候的同步性问题； 1.3.3 volatile的非原子性public class Test01 public static void main(String[] args) //启动两个线程，不断调用getNum()方法 MyInt myInt = new MyInt(); for(int i = 1; i = 2; i++) new Thread(new Runnable() @Override public void run() while(true) System.out.println(Thread.currentThread().getName() + - + myInt.getNum()); try TimeUnit.MILLISECONDS.sleep(100); catch (InterruptedException e) e.printStackTrace(); ).start(); static class MyInt volatile int num; public int getNum() return num++; 从结果可以发现，两个线程有的时候打印的是一样的值，说明即便是用volatile修饰了，num++还是不具有原子性。（可以使用原子类来保证原子性，例如AtomicInteger）。 第二章 线程同步详解(CAS、原子类、UnSafe)2.1 CAS2.1.1 什么是CASCAS，为Compare And Swap的缩写，中文翻译成比较并交换，是由硬件实现的。 CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。 2.1.2 CAS的原理在把值写到内存中时，会再次读取该地址的值，如果发现主存中的值与一开始读取到的值不同，则放弃写入（即撤销本次操作）；否则就更新进去。 使用CAS实现一个线程安全的计数器： public class CASTest public static void main(String[] args) CASCounter casCounter = new CASCounter(); for(int i = 0; i 1000; i++) new Thread(new Runnable() @Override public void run() System.out.println(Thread.currentThread().getName() + : + casCounter.increment()); , Thread + i).start(); class CASCounter private long value; private boolean compareAndSwap(long expectedValue, long oldValue, long newValue) if(expectedValue == oldValue) value = newValue; return true; else return false; public long increment() long oldValue = value; long newValue; do newValue = value + 1; while (compareAndSwap(value, oldValue, newValue)); return value; 2.1.3 CAS的ABA问题CAS实现原子性的背后有一个假设：如果共享变量的当前值与期望值相同，就假设共享变量没有被更改过。 但事实可能不是如此：x初始值位0，A将x修改为10，B将x又修改为0，此刻能否认为x没有被更改过呢？这就是CAS的ABA问题。 如果实际业务需要避免ABA问题，那么我们可以引入一个变量表示版本号，或者称修订号。每进行一次修改，修订号增加1。如果遇到当前版本号与期望版本号不一致，则获取新的版本号并继续修改。此时的过程是这样的。[A, 0] - [B, 1] - [C, 2] 2.2 Atomic原子类原子变量类是基于CAS实现的。当我们对共享变量进行read-modify-write的更新操作时，通过原子变量类可以保障操作的原子性和可见性。 read-modify-write操作指的是：对于此次操作，变量的新值依赖于变量的旧值。而不是像那种赋值操作。 前面提到过，volatile只能保障可见性，不能保障原子性。而原子变量类的内部使用的是volatile修饰的变量，并且使用CAS保障了原子性。有时将原子变量类看成是增强的volatile变量。 分组 原子变量类 基础原子类 AtomicInteger、AtomicLong、AtomicBoolean 数组原子类 AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray 字段更新原子类 AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater 引用原子类 AtomicReference、AtomicStampedReference、AtomicMarkableReference AtomicLong示例： //我们想要让整个计算过程只使用这一个计算器，所以这里我们将其设计成单例public class Indicator //将构造方法私有化 private Indicator() //创建一个静态的实例类 private static Indicator instance = new Indicator(); //返回上面的那个实例类 public static Indicator getInstance() return instance; //记录请求数 private AtomicLong requestNum = new AtomicLong(0); //记录成功数 private AtomicLong successNum = new AtomicLong(0); //记录失败数 private AtomicLong failureNum = new AtomicLong(0); //请求数增加 public void requestProcess() requestNum.incrementAndGet(); //成功数增加 public void requestProcessSuccess() successNum.incrementAndGet(); //失败数增加 public void requestProcessFailure() failureNum.incrementAndGet(); //获取请求数 public Long getRequestNum() return requestNum.get(); //获取成功数 public Long getRequestSuccessNum() return successNum.get(); //获取失败数 public Long getRequestFailureNum() return failureNum.get(); AtomicArray示例： public class Test public static void main(String[] args) //1、创建一个具有指定长度的原子数组 AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(10); System.out.println(atomicIntegerArray); //2、返回指定位置的元素 System.out.println(atomicIntegerArray.get(0)); System.out.println(atomicIntegerArray.get(1)); //3、设置指定位置元素的值 atomicIntegerArray.set(0, 1); System.out.println(atomicIntegerArray.getAndSet(0, 2)); //先获取旧值，再获取新值 //4、修改某个数组元素的值 System.out.println(atomicIntegerArray.addAndGet(0, 5)); //先修改，再返回 System.out.println(atomicIntegerArray.getAndAdd(0, 6)); //先返回，再修改 //5、CAS操作 atomicIntegerArray.compareAndSet(0, 13, 222); //如果0位置的值是22，就修改为222 System.out.println(atomicIntegerArray.get(0)); //6、自增/自减 System.out.println(atomicIntegerArray.incrementAndGet(0)); //先增再获得 System.out.println(atomicIntegerArray.getAndIncrement(0)); //先获得再增 System.out.println(atomicIntegerArray.decrementAndGet(0)); //先减再获得 System.out.println(atomicIntegerArray.getAndDecrement(0)); //先获得再减 AtomicIntegerFieldUpdater：字段更新器 AtomicIntegerFieldUpdater可以对原子整数字段进行更新，要求： 字段必须使用volatile修饰，是其在线程间可见。 只能是实例变量，不能是静态变量，也不能用final修饰 public class SubThread extends Thread //要更新的user对象 private User user; //创建更新器，对user对象的age字段进行更新 private AtomicIntegerFieldUpdaterUser updater = AtomicIntegerFieldUpdater.newUpdater(User.class, age); public SubThread(User user) this.user = user; @Override public void run() //在子线程中对user对象的age自增10次 for(int i = 0; i 10; i++) updater.incrementAndGet(user); AtomicReference：原子引用对象 public class Test01 //创建一个reference对象 static AtomicReferenceString atomicReference = new AtomicReference(abc); public static void main(String[] args) for(int i = 0; i 100; i++) int temp = i; new Thread(new Runnable() @Override public void run() atomicReference.set(atomicReference.get() + temp); System.out.println(atomicReference.get()); ).start(); AtomicStampedReference：解决CAS中的ABA问题 /** * AtomicStampedReference原子类可以用来解决CAS中的ABA问题 * AtomicStampedReference原子类中有一个整数标记值stamp，每次执行CAS操作时，会比较它的版本。 */public class Test01 private static AtomicStampedReferenceString atomicStampedReference = new AtomicStampedReference(abc, 0); public static void main(String[] args) throws InterruptedException Thread t1 = new Thread(new Runnable() @Override public void run() atomicStampedReference.compareAndSet(abc, def, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+1); System.out.println(Thread.currentThread().getName() + : + atomicStampedReference.getReference()); atomicStampedReference.compareAndSet(def, abc, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+1); ); Thread t2 = new Thread(new Runnable() @Override public void run() int stamp = atomicStampedReference.getStamp(); try TimeUnit.SECONDS.sleep(1); catch (InterruptedException e) e.printStackTrace(); System.out.println(atomicStampedReference.compareAndSet(abc, ggg, stamp, atomicStampedReference.getStamp()+1)); ); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(atomicStampedReference.getReference()); 2.3 Unsafe类Unsafe 是位于 sun.misc 包下的一个类，Unsafe 提供了CAS 方法，直接通过native 方式（封装 C++代码）调用了底层的 CPU 指令 cmpxchg。Unsafe类，翻译为中文:危险的，Unsafe全限定名是 sun.misc.Unsafe，从名字中我们可以看出来这个类对普通程序员来说是“危险”的，一般应用开发者不会用到这个类。 2.3.1 Unsafe 提供的 CAS 方法主要如下： 定义在 Unsafe 类中的三个 “比较并交换”原子方法 /*@param o 包含要修改的字段的对象@param offset 字段在对象内的偏移量@param expected 期望值（旧的值）@param update 更新值（新的值）@return true 更新成功 | false 更新失败*/public final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object update);public final native boolean compareAndSwapInt( Object o, long offset, int expected,int update);public final native boolean compareAndSwapLong( Object o, long offset, long expected, long update); 2.3.2 获取属性偏移量Unsafe 提供的获取字段（属性）偏移量的相关操作，主要如下： /*** @param o 需要操作属性的反射 * @return 属性的偏移量 */ public native long staticFieldOffset(Field field); public native long objectFieldOffset(Field field); staticFieldOffset 方法用于获取静态属性 Field 在 Class 对象中的偏移量，在 CAS 操作静态属性时，会用到这个偏移量。objectFieldOffset 方法用于获取非静态 Field （非静态属性）在 Object 实例中的偏移量，在 CAS 操作对象的非静态属性时，会用到这个偏移量。 2.3.3 根据属性的偏移量获取属性的最新值:/*** @param o 字段所属于的对象实例* @param fieldOffset 字段的偏移量 * @return 字段的最新值*/public native int getIntVolatile(Object o, long fieldOffset); 第三章 线程间通讯（等待通知机制）3.1 等待通知机制概念等待通知机制在我们生活中比比皆是，一个形象的例子就是厨师和服务员之间就存在等待通知机制。 厨师做完一道菜的时间是不确定的，所以菜到服务员手中的时间是不确定的； 服务员就需要去“等待（wait）”； 厨师把菜做完之后，按一下铃，这里的按铃就是“通知（nofity）”； 服务员听到铃声之后就知道菜做好了，他可以去端菜了。 在Java多线程中理解就是：等待通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()/notifyAll()方法，线程A收到通知后退出等待队列，进入可运行状态，进而执行后续操作。上面这样的一个过程就是等待通知机制 3.2 等待通知机制实现Object类中的wait()方法，可以使执行当前代码的线程等待，暂停执行。直到接到通知或被中断为止。 注意：wait()方法只能在同步代码块中由锁对象调用，且调用wait()方法后，当前线程会释放锁。 Object类的notify()方法可以唤醒处于等待的线程，该方法也必须在同步代码块中由锁对象调用。如果有多个等待的线程，notify()只能唤醒其中一个，具体唤醒哪一个是不知道的。被notify()的线程需要重新去竞争锁才能被执行。 没有使用锁对象就调用wait()notify()方法会产生异常：IllegalMonitorStateException。wait()代码实例 public class Test01 public static void main(String[] args) throws InterruptedException String test = abc; String another = def; System.out.println(同步代码块前的代码); synchronized (test) try System.out.println(wait前的代码); // another.wait(); 只有被锁住的对象才能调用wait()方法 test.wait(); System.out.println(wait后的代码); catch (IllegalMonitorStateException e) e.printStackTrace(); System.out.println(同步代码块后的代码); wait()notify()代码示例 /** * 需要通过notify唤醒线程 */public class Test02 public static void main(String[] args) String str = wa; Thread thread1 = new Thread(new Runnable() @Override public void run() synchronized (str) System.out.println(线程1开始等待); try str.wait(); catch (InterruptedException e) e.printStackTrace(); System.out.println(线程1被唤醒并执行结束了); , Thread1); Thread thread2 = new Thread(new Runnable() @Override public void run() synchronized (str) System.out.println(线程2唤醒线程1); str.notify(); , Thread2); thread1.start(); thread2.start(); 执行了notify()的线程并不会立即释放锁，而是执行完同步代码块的所有代码后才会释放锁 3.3 interrupt()方法会中断wait()当线程调用wait()处于等待状态时，调用线程对象的interrupt()方法会中断线程的等待状态，产生InterruptedException异常。 /** * interrupt()会中断线程的wait状态 */public class Test04 public static void main(String[] args) throws InterruptedException SubThread subThread = new SubThread(); subThread.start(); TimeUnit.SECONDS.sleep(1); subThread.interrupt(); private static final Object lock = new Object(); static class SubThread extends Thread @Override public void run() synchronized (lock) System.out.println(subThread wait); try lock.wait(); catch (InterruptedException e) System.out.println(wait等待被中断了); System.out.println(subThread end wait); 3.3.1 wait(long)方法的使用如果在指定时间内没有被唤醒，那么线程会自动唤醒。 public class Test06 public static void main(String[] args) SubThread subThread = new SubThread(); subThread.start(); static final Object lock = new Object(); static class SubThread extends Thread @Override public void run() synchronized (lock) try System.out.println(开始等待); lock.wait(5000); System.out.println(等待结束); catch (InterruptedException e) e.printStackTrace(); 3.4 notify()和notifyAll()的区别1） 唤醒数量不同notify()方法只会随机唤醒等待队列中的一个线程，而notifyAll()方法则会唤醒等待队列中的所有线程。 2）调用方式不同notify()和notifyAll()方法都必须在同步代码块中调用，并且必须包含在synchronized块中，且必须是该对象的监视器对象才能够调用。而且只有在获取了锁之后才能调用，否则会抛出IllegalMonitorStateException异常。 3） 竞争情况不同notify()方法只会唤醒等待队列中的一个线程，并使其与其他线程竞争获取锁，这可能会导致某些线程无法被唤醒或者一直处于等待状态。notifyAll()方法则会唤醒等待队列中的所有线程，并使它们竞争获取锁，这样可以使所有线程都有机会获取锁并进入运行状态，从而避免了一些线程一直处于等待状态。 第四章 线程间通讯（生产者消费者机制）在Java中，负责生产数据的是生产者，负责使用数据的是消费者。没有数据时，消费者等待；数据满时，生产者等待。 生产者-消费者模型（Producer-Consumer problem）是一个非常经典的多线程并发协作的模型。 比如某个模块负责生产数据，而另一个模块负责处理数据。产生数据的模块就形象地被称为生产者；而处理数据的模块，则被称为消费者。 生产者和消费者在同一段时间内共用同一个存储空间，生产者往存储空间中添加产品，消费者从存储空间中取走产品，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。 4.1 生产者-消费者模式所遵循的规则 生产者仅仅在缓冲区未满时生产，缓冲区满则停止生产。 消费者仅仅在缓冲区有产品时才能消费，缓冲区为空则停止消费。 当消费者发现缓冲区没有可消费的产品时会通知生产者。 当生产者生产出可消费的产品时，应该通知等待的消费者去消费。 4.2 生产者-消费者模型的实现生产者-消费者模型的实现可以有多重实现方式，这里我们重点介绍3种，对于初学者，可以先重点掌握第2种方式。 4.2.1 通过阻塞队列方式实现public class ProducerConsumerDemo1 /** * 缓冲队列 */ private final ArrayBlockingQueueInteger blockingQueue = new ArrayBlockingQueue(10); /** * 生产者 */ class Producer implements Runnable @Override public void run() for (int i = 0; i 10; i++) try Thread.sleep(1000); catch (InterruptedException e) e.printStackTrace(); blockingQueue.put(i); /** * 消费者 */ class Consumer implements Runnable @Override public void run() for (int i = 0; i 10; i++) try Thread.sleep(1000); catch (InterruptedException e) e.printStackTrace(); blockingQueue.take(); public Producer getProducer() return new Producer(); public Consumer getConsumer() return new Consumer(); public static void main(String[] args) ProducerConsumerDemo1 producerConsumerDemo1 = new ProducerConsumerDemo1(); new Thread(producerConsumerDemo1.getProducer()).start(); new Thread(producerConsumerDemo1.getConsumer()).start(); 4.2.2 通过wait和notifyAll来实现/** * 缓冲区（仓库） */private final ListObject list = new ArrayList(); private final int bufferCount = 10; public final Object lock = new Object(); /** * 生产者 */class Producer implements Runnable @Override public void run() for (int i = 0; i 10; i++) try Thread.sleep(1000); catch (InterruptedException e) e.printStackTrace(); synchronized (lock) while (list.size() = bufferCount) try lock.wait(); catch (InterruptedException e) e.printStackTrace(); //仓库未满，继续生产产品 list.add(new Object()); //唤醒消费者去消费产品 lock.notifyAll(); /** * 消费者 */class Consumer implements Runnable @Override public void run() for (int i = 0; i 10; i++) try Thread.sleep(1000); catch (InterruptedException e) e.printStackTrace(); synchronized (lock) while (list.size() == 0) try lock.wait(); catch (InterruptedException e) e.printStackTrace(); //仓库不是空，继续消费 list.remove(0); //唤醒生产者去生产产品 lock.notifyAll(); public Producer getProducer() return new Producer(); public Consumer getConsumer() return new Consumer(); public static void main(String[] args) ProducerConsumerDemo2 producerConsumerDemo2=new ProducerConsumerDemo2(); new Thread(producerConsumerDemo2.getProducer()).start(); new Thread(producerConsumerDemo2.getConsumer()).start(); 注意：为什么使用notifyAll()而不使用notify()？因为假设只有一个生产者和消费者：那么生产者和消费者将按顺序执行。 但是如果有多个生产者和消费者，那么可能出现假死现象： 1） 一个消费者唤醒了一个生产者，但是在这个生产者拿到锁之前，另一个消费者抢先拿到了锁；2）三个生产者全部等待，某个消费者唤醒的不是生产者，而是另一个消费者；而解决上述假死现象的方法是使用notifyAll()替换notify()，保证消费者唤醒了生产者，生产者唤醒了消费者。 4.2.3 通过ReentrantLock和Condition来实现public class ProducerConsumerDemo3 /** * 缓冲区（仓库） */ private final ListObject list = new ArrayList(); /** * 缓冲区大小 */ private final int bufferCount = 10; public ReentrantLock lock = new ReentrantLock(); //创建两个条件变量 private final Condition condition1 = lock.newCondition(); private final Condition condition2 = lock.newCondition(); /** * 生产者 */ class Producer implements Runnable @Override public void run() for (int i = 0; i 10; i++) try Thread.sleep(1000);//模拟生产操作 catch (InterruptedException e) e.printStackTrace(); try lock.lock(); while (list.size() = bufferCount) condition1.await();//当仓库数据数量超过缓冲区设定的最大数量，则让生产线程进入等待状态 list.add(new Object()); System.out.println(Thread.currentThread().getName() + -生产者生产，数量为： + list.size()); condition2.signal();//唤醒消费线程 catch (InterruptedException e) e.printStackTrace(); finally lock.unlock(); class Consumer implements Runnable @Override public void run() for (int i = 0; i 10; i++) try Thread.sleep(1000); catch (InterruptedException e) e.printStackTrace(); try lock.lock(); while (list.size() == 0) condition2.await();//当仓库中数据为空时，则让消费线程进入等待状态 list.remove(0); System.out.println(Thread.currentThread().getName() + -消费者消费，数量为： + list.size()); condition1.signal();//唤醒生产线程 catch (InterruptedException e) e.printStackTrace(); finally lock.unlock(); public Producer getProducer() return new Producer(); public Consumer getConsumer() return new Consumer(); public static void main(String[] args) ProducerConsumerDemo3 producerConsumerDemo3 = new ProducerConsumerDemo3(); new Thread(producerConsumerDemo3.getProducer()).start(); new Thread(producerConsumerDemo3.getConsumer()).start(); 第五章 详解：Java多线程通过管道实现线程间通信5.1 案例场景按照用户搜索条件查询数据，并将数据下载到用户本地。那系统通常的做法就是按照用户检索条件查询出结果集，将结果集生成excel表，在将excel表上传到ftp或者oss云盘之类的地方，最后将下载连接发送给用户，最后用户点击链接进行下载，那么使用管道就减少了数据生成到本地，在上传到云盘的工作，直接生成到用户下载，提高用户体验和效率。 5.2 管道使用方式Java.io包的PipeStream管道流用于在线程之间传递数据，一个线程通过管道输出数据，另一个线程从管道中输入数据。相关类包括： PipedInputStream PipedOutputStream PipedReader PipedWriter 前两种是基础字节流，后两种是基础字符流。 5.3 代码案例5.3.1 案例1：PipedInputStream和PipedOutputStream使用PipedInputStream和PipedOutputStream在线程间传递字节流： public class Test public static void main(String[] args) throws IOException //定义管道字节流 PipedInputStream in = new PipedInputStream(); PipedOutputStream out = new PipedOutputStream(); //建立管道之间的关系 in.connect(out); //创建两个线程，分别往管道里写数据，和读数据 new Thread(new Runnable() @Override public void run() try writeData(out); catch (IOException e) e.printStackTrace(); , Thread1).start(); new Thread(new Runnable() @Override public void run() try readData(in); catch (IOException e) e.printStackTrace(); , Thread2).start(); //向管道流中写入数据 public static void writeData(PipedOutputStream out) throws IOException //分别把0～100的数据写入管道 try for(int i = 0; i = 100; i++) //把字节数组写入到输出管道流中 out.write(( + i).getBytes(StandardCharsets.UTF_8)); catch (IOException e) e.printStackTrace(); finally out.close(); //从管道流中读取数据 public static void readData(PipedInputStream in) throws IOException int count = 0; byte[] bytes = new byte[1024]; int len = 0; try while((len = in.read(bytes)) != -1) System.out.println(new String(bytes, 0, len)); catch (IOException e) e.printStackTrace(); finally in.close(); 5.3.2 案例2：PipedWriter和PipedReaderPipedWriter、PipedReader实现多线程从控制台读取用户输入输出： public class PipedTeset public static void main(String[] args) throws IOException PipedReader in = new PipedReader(); PipedWriter out = new PipedWriter(); out.connect(in); Thread printThread = new Thread(new PrintThread(in), printThread); printThread.start(); int receive = 0; try while ((receive = System.in.read()) != -1) // 主线程进行读取控制台输入 out.write(receive); catch (RuntimeException e) static class PrintThread implements Runnable private PipedReader in; public PrintThread(PipedReader in) this.in = in; @Override public void run() int receive; try while ((receive = in.read()) != -1) // printThread 收到字符然后输入，这里可以使用sokcet编程将字符传输到对应计算机中 System.out.print((char) receive); catch (IOException e) throw new RuntimeException(e);","tags":["java","多线程","基础"],"categories":["java","多线程","基础"]},{"title":"Java 多线程基础","path":"/2025/09/23/Java-Thread/","content":"第一章 线程和进程的概念及区别1.1进程概念简单的来说：进程（process）就是被加载到内存中的可执行程序。更准确的来说，进程是有特定功能的程序在一个数据集上一次动态执行的过程。进程是操作系统执行任务的基本单元，也是分配资源和调度的基本单元。 1.2线程概念线程（Thread）是进程的一个执行单元，是操作系统能够进行运算调度的最小单位。进程是线程的容器，一个进程至少有一个线程，一个进程可以同时并发运行多个线程，它被包含在进程之中，是进程中的实际运作单位。 1.3进程与线程的区别 本质区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。 包含关系：进程基本上相互独立的，而线程存在于进程内，是进程的一个子集，一个进程至少有一个线程，线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 进程拥有共享的资源，如内存空间等，供其内部的线程共享 进程间通信较为复杂，同一台计算机的进程通信称为 IPC（Inter-process communication），不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP。线程通信相对简单，因为它们共享进程内的内存，比如多个线程可以访问同一个共享变量 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低 1.4主线程和子线程关系JVM启动时会创建一个主线程，该主线程负责执行main方法。主线程就是执行main方法的线程。 JAVA中的线程不是孤立的，线程之间也会存在一些联系。如果A线程创建了B线程，那么A线程就是B线程的父线程，B线程就是A线程的子线程。 1.5并行、并发、同步、异步什么是并行两个或两个以上的系统作业在同一时间段内执行。 什么是并发两个或两个以上的系统作业在同一时刻执行。 什么是同步一个调用发起之后，会等待结果返回，结果不返回，自己不结束。 什么是异步一个调用发起之后，不等待结果返回，自己直接结束。 第二章 线程的生命周期线程的整个生命周期可以分为 5 个阶段（状态），分别是： 新建状态(New) 就绪状态(Runnable) 运行状态(Running) 阻塞状态(Blocked) 死亡状态(Terminated) 但在JDK1.5 之后，变成了6种状态： 将准备和运行合并为一个Runnable状态 将阻塞细分为：计时等待、锁阻塞、无线等待3种状态 线程生命周期可以通过getState()方法获得，线程的状态是Thread.State枚举类型定义的，由以下几种组成： NEW ：新建状态。创建了线程对象，在调用start()启动之前的状态 RUNNABLE：可运行状态，它包括READY和RUNNING两个状态。READY状态表示线程可以被线程调度器进行调度，来使它变成RUNNING状态。RUNNING状态表示该线程正在被执行。Thread.yield()方法可以把线程由RUNNING状态转换为READY状态。 BLOCKED ：阻塞状态。线程发起阻塞的IO操作，或者申请由其他线程占用的独占资源，线程会转化为BLOCKED阻塞状态。处于阻塞状态的线程不会占用CPU资源。当阻塞IO操作执行完，或者线程获得了其申请的资源，线程可以转换为RUNNABLE WAITING：等待状态。线程执行了object.wait()或者thread.join()方法，会把线程转换为WAITING等待状态。执行object.notify()方法，或者加入的线程执行完毕，当前线程会转换为RUNNABLE状态。 TIMED_WAITING ：与WAITING状态类似，都是等待状态。区别在于，处于该状态的线程不会无限期地等待。如果线程没有在指定的时间范围内完成期望操作，该线程自动转换为RUNNABLE状态。TERMINATED：终止状态。线程结束处于终止状态。 2.1 Java线程的生命周期的状态转换线程的不同状态表明了线程当前正在进行的活动。在程序中，通过一些操作可以使线程在不同状态之间转换：上图中展示了线程各种状态的转换关系，箭头表示可转换的方向，其中，单箭头表示状态只能单向的转换，例如，线程只能从新建状态转换到就绪状态，反之则不能。双箭头表示两种状态可以互相转换，例如，就绪状态和运行状态可以互相转换。通过一张图还不能完全描述清楚线程各状态之间的区别，接下来针对线程生命周期中的五种状态分别进行详细讲解，具体如下。 2.1.1. 新建状态(New)创建一个线程对象后，该线程对象就处于新建状态，此时它不能运行，与其他 Java 对象一样，仅仅由 Java 虚拟机为其分配了内存，没有表现出任何线程的动态特征。 2.1.2. 就绪状态(Runnable)当线程对象调用了 start()方法后，该线程就进入就绪状态。处于就绪状态的线程位于线程队列中，此时它只是具备了运行的条件，能否获得 CPU 的使用权并开始运行，还需要等待系统的调度。 2.1.3. 运行状态(Running)如果处于就绪状态的线程获得了 CPU 的使用权，并开始执行 run()方法中的线程执行体，则该线程处于运行状态。一个线程启动后，它可能不会一直处于运行状态，当运行状态的线程使用完系统分配的时间后，系统就会剥夺该线程占用的 CPU 资源，让其他线程获得执行的机会。需要注意的是，只有处于就绪状态的线程才可能转换到运行状态。 2.1.4.阻塞状态(Blocked)一个正在执行的线程在某些特殊情况下，如被人为挂起或执行耗时的输入输出操作时，会让出 CPU 的使用权并暂时中止自己的执行，进人阻塞状态。线程进人阻塞状态后，就不能进入排队队列。只有当引起阻塞的原因被消除后，线程才可以转入就绪状态。 2.1.5.死亡状态(Terminated)如果线程调用 stop()方法或 nun()方法正常执行完毕，或者线程抛出一个未捕获的异常(Exception)错误(Error)，线程就进入死亡状态。一旦进入死亡状态，线程将不再拥有运行的资格，也不能再转换到其他状态。 在JDK1.5 之后，线程生命周期转换图如下： 第三章 Java线程创建Java创建线程的4种方式 继承Thread类 实现Runnable接口 实现Callable接口 线程池创建 3.1 方式1：继承Thread类步骤： 创建一个继承于Thread类的子类 重写Thread类的run()方法 - 此线程执行的操作声明在方法体中 创建当前Thread子类的对象 通过实例对象调用start()方法，启动线程 - Java虚拟机会调用run()方法 public class MyThread extends Thread // 共享数据要放在run()方法外边才能被共享且声明为static，否则就是每个线程都会调用run()方法，都会单独拥有一个run()方法里的独享数据，而非共享数据 //eg: static int trick = 100; //定义指定线程名称的构造方法 public MyThread(String name) //调用父类的String参数的构造方法，指定线程的名称 super(name); // 重写run @Override public void run() for (int i = 10; i 0; i--) System.out.println(Thread.currentThread().getName() + 线程正在运行任务，输出：+i); 运行，当调用start()方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的run()方法； public class Test01 public static void main(String[] args) //创建自定义线程对象1 MyThread mt1 = new MyThread(子线程1); //开启子线程1 mt1.start(); //创建自定义线程对象2，分别创建对象开启线程，不可以数据共享，若要共享需要创建static变量 MyThread mt2 = new MyThread(子线程2); //开启子线程2 mt2.start(); 我们还可以通过创建Thread类的匿名子类的匿名对象来运行线程： // 创建Thread类的匿名子类的匿名对象，并启动线程new Thread() public void run() // 执行的操作 .strat(); // 启动线程 3.2 方式2：实现 Runnable 接口相比继承 Thread 类，Runnable避免了单继承的局限性；run方法只关于运行逻辑，解耦合；Thread 代表线程，Runnable 可运行的任务（线程要执行的代码）。 Runnable把线程和任务分开了，更容易与线程池等高级 API 配合，让任务类脱离了 Thread 继承体系，使用更加灵活。 步骤： 创建一个实现Runnable接口的类 实现接口中的run()方法 —- 线程执行的操作声明在此方法中 创建实例对象 将此对象作为参数传到Thread类的构造器中，创建Thread类的实例 通过Thread的实例对象调用strat()方法，启动线程 —- Java虚拟机会调用run()方法 要知道，虽然实现Runnable，但最终还是通过Thread类来实现的。创建线程类，实现Runnable接口及run()方法； public class MyRunnable implements Runnable @Override public void run() for (int i = 10; i 0; i--) System.out.println(Thread.currentThread().getName() + 线程正在运行任务，输出：+i); 创建Runnable实现类的实例，并把实例作为Thread类的Target创建对象，并调用对象start()方法来启动线程； public class Test002 public static void main(String[] args) MyRunnable myRunnable = new MyRunnable(); // 创建启动第1个线程 Thread t1 = new Thread(myRunnable); t1.start(); // 创建启动第2个线程 Thread t2 = new Thread(myRunnable); t2.start(); 我们还可以创建Runnable接口的匿名子类的匿名对象来运行线程： new Thread(new Runnable() public void run() // 执行的操作 ).start(); // 开启线程 3.3 方式3：实现 Callable 接口与实现Runnable接口类似，但是Callable是支持返回值的。创建线程类，实现Callable接口，实现call方法，与Runnable相比，Callable可以有返回值，返回值通过FutureTask进行封装。 public class MyCallable implements CallableString @Override public String call() throws Exception for (int i = 10; i 0; i--) System.out.println(Thread.currentThread().getName() + 线程正在运行任务，输出：+i); return MyCallable; 运行Callable线程： public class Test003 public static void main(String[] args) throws ExecutionException, InterruptedException MyCallable myCallable = new MyCallable(); FutureTaskString futureTask1 = new FutureTask(myCallable); Thread thread1 = new Thread(futureTask1); thread1.start(); System.out.println(futureTask1.get()); 3.4 方式4：通过线程池方式如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。 那么有没有一种办法使得线程可以复用，即执行完一个任务，并不被销毁，而是可以继续执行其他的任务？ 思路： 提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用 public class ThreadTest static ExecutorService service = Executors.newFixedThreadPool(2);//实例创建的为使用的固定线程的线程池 public static void main(String[] args) throws ExecutionException, InterruptedException System.out.println(main方法开始); service.execute(new MyRunnable());//传入一个Runable对象 service.shutdown();//关闭线程池 System.out.println(main方法结束); 继承Thread类 和 实现Runnable接口对比 共同点： 都是通过Thread类中定义的start()来启动线程。 都是通过Thread类或其子类的实例对象来创建线程。 不同点： Thread是继承 Runnable是实现 Runnable好处： 通过实现的方式，避免了类的单继承的局限性 自动共享数据，更适合处理有共享数据的业务逻辑 实现了逻辑代码（在run()方法中）和数据（在创建线程的方法中）的分离 第四章 Java Thread类核心API详解1、获取当前线程对象、线程名称和ID2、线程休眠sleep和yield3、设置线程优先级4、设置守护线程5、线程上下文类加载器6、线程中断7、线程join 不常见的APIyield方法属于一种启发式的方法，调用该方法时会提醒调度器当前线程愿意放弃当前CPU的使用权，如果CPU的资源不紧张，CPU会忽略这种提示。调用yield方法会使当前线程从RUNNING状态切换到RUNNABLE状态，由于不一定会生效，一般这个方法不太常用。主要是为了测试和调试。public static native void yield(); sleep和yield的区别yield在jdk1.5之前实际上是调用了sleep(0)，但sleep与yield之间还是有一些本质的区别：1、 sleep会导致当前线程暂停指定的时间，没有CPU时间片的消耗；2、 yield只是对CPU调度器的一个提示，如果CPU调度器没有忽略这个提示，它会导致线程上下文的切换；3、 sleep会使线程短暂block，会在给定的时间内释放CPU资源；4、 yield会使RUNNING状态的Thread进入RUNNABLE状态（如果CPU调度器没有忽略这个提示的话）；5、 sleep几乎百分之百地完成了给定时间的休眠，而yield的提示并不能一定担保；6、 一个线程sleep另一个线程调用interrupt会捕获到中断信号，而yield则不 4.1 守护线程 setDaemon什么是守护线程和用户线程？在Java中有两类线程：用户线程 (User Thread)、守护线程 (Daemon Thread)。 用户线程：我们平常创建的普通线程。 守护线程：守护线程是一类比较特殊的线程，一般用于处理一些后台的工作，随着用户线程的销毁，守护线程也会随着销毁，比如JDK的垃圾回收线程。 Java线程中对于守护线程的使用主要是依靠setDaemon(boolean on)方法 方法作用: 是否将此线程设置为守护线程，如果设置为true则为守护线程。 代码示例：要设置守护线程，首先创建一个线程对象，然后调用setDaemon(true)方法将其设置为守护线程，最后调用start()方法启动线程。 public class DaemonThreadExample public static void main(String[] args) Thread thread = new Thread(new MyRunnable()); thread.setDaemon(true); thread.start(); // 主线程继续执行其他任务 class MyRunnable implements Runnable @Override public void run() // 守护线程的任务逻辑 while (true) System.out.println(守护线程正在执行...); try Thread.sleep(1000); catch (InterruptedException e) e.printStackTrace(); 在上面的例子中，MyRunnable类实现了Runnable接口，并重写了run()方法，该方法中的逻辑会不断地打印一行信息。在main()方法中，我们创建了一个线程对象，并将其设置为守护线程，然后启动线程。最后，主线程继续执行其他任务，而守护线程会在后台一直执行。 守护线程的使用场景守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。 Java垃圾回收线程就是一个典型的守护线程，因为我们的垃圾回收是一个一直需要运行的机制，但是当没有用户线程的时候，也就不需要垃圾回收线程了，守护线程刚好满足这样的需求。 场景：某个用户线程在执行时，需要一个定时无线循环线程，去检测心跳，一旦用户线程结束，这个检测线程也需要关闭。如果不设置守护线程，那个这个检测线程将无法停止，此时可以这只设置这个线程为守护线程，随着业务线程的完成而自动退出。 注意事项 1） 设置守护线程的方法很简单，调用setDaemon方法即可，true代表守护线程，false代表正常线程； 2）线程是否为守护线程和它的父线程有很大的关系，如果父线程是正常线程，则子线程也是正常线程，反之亦然，如果你想要修改它的特性则可以借助setDaemon方法isDaemon方法可以判断该线程是不是守护线程； 3） setDaemon(true)必须在t.start()之前设置，否则会抛出IllegalThreadStateException异常； 4）守护线程不能持有任何会导致程序继续执行的资源，比如打开的文件或数据库连接，否则可能会导致资源泄露或数据不一致的问题。 第五章 Java线程池5.1 线程池概念线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务，并且线程池中的线程都是后台线程。 5.2 线程池的意义 第1：降低资源消耗。通过重复利用机制已降低线程创建和销毁造成的消耗。 第2：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 第3：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。 5.3 Java四种线程池的使用JDK1.5中引入的Executor框架把任务的提交和执行进行解耦，只需要定义好任务，然后提交给线程池，而不用关心该任务是如何执行、被哪个线程执行，以及什么时候执行。Java通过Executors为我们提供了四种线程池的创建方式，分别为： 5.3.1 newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 // 可缓存线程池 Executors表示启动线程的 可创建线程数是无限大小的 ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i 10; i++) final int temp = i; // 可执行线程 execute 启动线程 executorService.execute(new Runnable() public void run() System.out.println(Thread.currentThread().getName() + , + temp); ); //停止线程池 executorService.shutdown(); 5.3.2 newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 //创建可固定长度的线程池，只会创建5个线程池进行处理 ExecutorService executorService = Executors.newFixedThreadPool(5); for (int i = 0; i 20; i++) final int temp = i; // 可执行线程 execute 启动线程 executorService.execute(new Runnable() public void run() System.out.println(Thread.currentThread().getName() + , + temp); ); //停止线程池 executorService.shutdown(); 5.3.3 newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。 //创建可定时执行的线程池 数量为3 ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(3); for (int i = 0; i 10; i++) final int temp=i; //schedule 方法表示线程执行 表示延迟5秒之后 开始执行线程 scheduledExecutorService.schedule(new Runnable() public void run() System.out.println(Thread.currentThread().getName()++temp); , 5, TimeUnit.SECONDS); //停止线程池 scheduledExecutorService.shutdown(); 5.3.4 newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO， LIFO， 优先级）执行。 //创建单线程线程池 ExecutorService executorService = Executors.newSingleThreadExecutor(); for (int i = 0; i 10; i++) final int temp = i; // 可执行线程 execute 启动线程 executorService.execute(new Runnable() public void run() System.out.println(Thread.currentThread().getName() + , + temp); ); //停止线程池 executorService.shutdown(); 5.4 Executors类源码查看Executors类源码，以newSingleThreadExecutor 方法为例： 我们发现其实都是在使用ThreadPoolExecutor类进行构建的，然后该类目构造方法有很多参数。这些参数很重要，需要掌握，面试也会经常被问到！ 5.5 ThreadPoolExecutor线程池类7大参数详解 参数 含义 corePoolSize 核心线程数量，线程池维护线程的最少数量 maximumPoolSize 线程池维护线程的最大数量 keepAliveTime 线程池除核心线程外的其他线程的最长空闲时间，超过该时间的空闲线程会被销毁 unitkeepAliveTime的单位 TimeUnit中的几个静态属性：NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS workQueue 线程池所使用的任务缓冲队列 threadFactory 线程工厂，用于创建线程，一般用默认的即可 rejectHandler 线程池拒绝任务时的处理策略 5.6 Java线程池执行流程一个线程提交到线程池后的具体处理流程如下图所示： 如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。 如果此时线程池中的数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列。 如果此时线程池中的数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。 如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。 当线程池中的线程数量大于corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。 总结：处理任务判断的优先级为 核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler采取任务拒绝策略进行处理；线程池的拒绝策略：当最大线程数 + 队列缓存数量 小于线程数量的时候，程序运行出错，被拒绝。（在此不再详细展开） 5.7 Java自定义线程池虽然JDK的Executors提供了4大类线程池供我们直接使用，但是在实际生产开发中，往往是不允许不建议使用这4种直接调用的方式的，比如在阿里巴巴的Java开发手册中就有如下【强制】要求： 原因就是因为直接创建会容易导致OOM（内存溢出~）推荐我们手工自定义线程池，在自定义时我们需要预估线程数多少合适，主要参考依据为核心线程数计算公式： IO密集型：核心线程数 CPU核数 （1-阻塞系数） CPU密集型：核心线程数 CPU核数 + 1 IO密集型：核心线程数 CPU核数 * 2 1. CPU密集型比如像加解密，压缩、计算等一系列需要大量耗费 CPU 资源的任务，大部分场景下都是纯 CPU 计算理论上线程的数量 CPU 核数就是最合适的，不过通常把线程的数量设置为CPU 核数 +1，会实现最优的利用率。即使当密集型的线程由于偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程也能确保 CPU 的时钟周期不会被浪费，从而保证 CPU 的利用率。公式：设置为CPU 核数 +1 2. IO密集型比如像 MySQL 数据库、文件的读写、网络通信等任务，这类任务不会特别消耗 CPU 资源，但是 IO 操作比较耗时，会占用比较多时间公式：线程数 CPU 核心数 * (1 + IO 耗时 CPU 耗时) 可以创建个工具类如下： import com.google.common.util.concurrent.ThreadFactoryBuilder;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadFactory;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit; public class ThreadPoolUtil /** * 默认 CPU 核心数 */ private static int threadPoolSize = 0; static // 获取服务器 CPU 核心数 threadPoolSize = Runtime.getRuntime().availableProcessors(); System.out.println( CPU 核心数量: + threadPoolSize); public static int getThreadPoolSize() return threadPoolSize; /** * 线程工厂，用来创建线程 */ private static ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(thread-pool-demo-%d).setDaemon(true).build(); /** * 设置线程池核心参数(IO 密集型) 核心线程数 = CPU 核数 * 2 * 参数依次分别为上面的的7大参数，最后拒绝策略参数可以不写，则默认使用AbortPolicy */ private static ThreadPoolExecutor threadPoolExecutorIO = new ThreadPoolExecutor(threadPoolSize, threadPoolSize * 2, 0L, TimeUnit.SECONDS, new LinkedBlockingQueue(1024), threadFactory, new ThreadPoolExecutor.AbortPolicy()); /** * 设置线程池核心参数(CPU 密集型) 核心线程数 = CPU 核数 + 1 // 核心线程数 = CPU 核数 + 1 */ private static ThreadPoolExecutor threadPoolExecutorCPU = new ThreadPoolExecutor(threadPoolSize, threadPoolSize + 1, 0L, TimeUnit.SECONDS, new LinkedBlockingQueue(1024), threadFactory, new ThreadPoolExecutor.AbortPolicy()); /** * 返回线程池对象 * * @return */ public static ThreadPoolExecutor getThreadPoolExecutorIO() return threadPoolExecutorIO; public static ThreadPoolExecutor getThreadPoolExecutorCPU() return threadPoolExecutorCPU; 如果你不想区分CPU密集型还是IO密集型，只是想简单的自己手工创建一个线程池，比如我这里只想创建一个SingleThreadExecutor，则代码如下： ExecutorService executorService = new ThreadPoolExecutor( 1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueueRunnable(1024), new ThreadFactoryBuilder().setNameFormat(thread-pool-demo-%d).setDaemon(true).build() );for (int i = 0; i 10; i++) final int temp = i; // 可执行线程 execute 启动线程 executorService.execute(new Runnable() public void run() System.out.println(Thread.currentThread().getName() + , + temp); ); 第六章 线程安全6.1 线程安全问题非线程安全：主要是指多个线程对同一个对象的实例变量进行操作时，会出现值被更改，值不同步的问题。 线程安全：原子性、可见性、有序性 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作（Atomic、CAS算法、synchronized、Lock） 可见性：一个主内存的线程如果进行了修改，可以及时被其他线程观察到（synchronized、volatile） 有序性：如果两个线程不能从 happens-before原则 观察出来，那么就不能观察他们的有序性，虚拟机可以随意的对他们进行重排序，导致其观察观察结果杂乱无序（happens-before原则） 6.2 原子性原子(Atomic)就是不可分割的意思。一条线程在执行一系列程序指令操作时，该线程不可中断。一旦出现中断，那么就可能会导致程序执行前后的结果不一致。与数据库中的原子性（事务管理体现）是相同的 概括：一段程序只能由一条线程去完整的执行，不能被多个线程干扰执行。 原子操作的不可分割有两层含义： 访问（读、写）某个共享变量的操作从其他线程来看，该操作要么已经执行完毕，要么尚未发生。即其他线程看不到当前操作的中间结果。 访问同一组共享变量的原子操作，是不能够交叉的。 Java有两种方式保证原子性： 使用锁：锁具有排它性，保证共享变量在某一时刻只能被一个线程访问。 利用处理器的CAS（Compare and Swap）指令：CAS指令直接在硬件（处理器和内存）层次上实现原子性，可以看作是硬件锁。 以下这段代码因为没有考虑原子性，导致这两个线程读取的num值有时候是一样的（因为num++其实是分步执行的）。 public static void main(String[] args) //启动两个线程，不断调用getNum()方法 MyInt myInt = new MyInt(); for(int i = 1; i = 2; i++) new Thread(new Runnable() @Override public void run() while(true) System.out.println(Thread.currentThread().getName() + - + myInt.getNum()); try TimeUnit.MILLISECONDS.sleep(100); catch (InterruptedException e) e.printStackTrace(); ).start(); static class MyInt int num; public int getNum() return num++; 6.3 可见性简介：一个线程对主内存的修改可以及时被其他线程观察到。 在多线程环境中，一个线程对某个共享变量进行更新后，后续其他的线程可能无法立即读取到这个更新后的结果。这是线程安全问题的另一种形式：可见性（visibility）。 如果一个线程对共享变量更新后，后续访问该变量的其他线程可以马上读到更新的结果，称这个线程对共享变量的更新对其他线程具有可见性；反之称为没有可见性。 多线程程序可能因为可见性，导致其他线程读取到了旧数据（脏数据）。 导致共享变量在线程间不可见的原因： 线程交叉执行 重新排序结合线程交叉执行 共享变量更新后的值没有在工作内存中与主内存间及时更新 下面这段代码可能出现这种情况：在main线程中调用了myTask的cancel()方法修改toCancel为true，但是myTask线程看不到。 //测试线程的可见性public class Test02 public static void main(String[] args) throws InterruptedException MyTask myTask = new MyTask(); new Thread(myTask).start(); TimeUnit.MILLISECONDS.sleep(1000); myTask.cancel(); static class MyTask implements Runnable private boolean toCancel = false; @Override public void run() while(!toCancel) doSomething(); if(toCancel) System.out.println(任务被取消); else System.out.println(任务正常结束); private boolean doSomething() System.out.println(执行某个任务); try TimeUnit.MILLISECONDS.sleep(1000); //模拟任务执行需要的时间 catch (InterruptedException e) e.printStackTrace(); return true; public void cancel() toCancel = true; 原因： JIT及时编译器可能对while循环进行优化： if(!toCancel) while(true) doSomething(); 可能与计算机的存储系统有关假设main线程和myTask线程分别运行在两个cpu上，而一个cpu不能立即读取到另一个cpu中的数据； 6.4 有序性有序性（Ordering）：在某种情况下，一个处理器上某个线程执行的内存访问操作，在另一个处理器上的线程看来是乱序的。 在JMM中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 通过volatile、synchronized、lock保证有序性 与内存操作顺序相关的概念： 源代码顺序：源码中指定的操作顺序 程序顺序：处理器上目标代码的顺序 执行顺序：内存访问操作在处理器上的实际操作顺序 感知顺序：处理器感受到该处理器和其他处理器的内存操作顺序 重排序可以分为指令重排序和存储子系统重排序： 指令重排序主要是由JIT编译器、处理器引起的，指程序顺序和执行顺序不一致 存储子系统重排序是由高速缓存、写缓冲器引起的，感知顺序与执行顺序不一致 指令重排序：当源代码顺序和程序顺序不一致，或者程序顺序与执行顺序不一致的情况下，我们就说发生了指令重排序（Instruction Reorder）。 指令重排是一种动作，确实对指令进行了调整，重排序的对象是指令。Java编译器一般不会进行指令重排，但是JIT可能会执行这个操作。 处理器也可能执行指令重排，使得执行顺序和程序顺序不一致。 指令重排不会对单线程程序的结果产生影响，但是可能对多线程程序的结果产生影响。 存储子系统重排序：存储子系统指的是高速缓存和写缓冲器： 高速缓存指的是CPU为了弥补其与主存储器处理速度不一致的问题而设置的，目的是提高CPU读取数据的速度。 写缓冲器，用来提高写高速缓存的效率。 即使严格按照程序顺序的两个内存访问操作，在存储子系统的作用下，其他处理器对这两个操作的感知顺序可能不一样，即这两个操作的顺序看起来像是发生了变化，这就是存储子系统重排序。 存储子系统重排序并没有对指令执行顺序产生影响，而是造成指令执行顺序被调整的假象。 存储子系统操作的对象是内存操作的结果 6.5 线程安全性总结 原子性：Atomic包、CAS算法、synchronized、Lock 原子性做了互斥方法，同一个线程只能有一个进行操作 可见性：synchronized、volatile 一个主内存的线程如果进行了修改，可以及时被其他线程观察到，介绍了volatile如何被观察到的 有序性：happens-before原则。happens-before原则，观察结果，如果两个线程不能偶从happens-before原则观察出来，那么就不能观察他们的有序性，虚拟机可以随意的对他们进行重排序 第七章 多线程内存模型Java多线程内存模型是基于Cpu缓存模型建立的，它的作用是屏蔽掉不同硬件和操作系统的内存访问差异，实现各种平台具有一致的并发效果。 1、 每个线程都有独立的栈空间；2、 每个线程都可以访问堆内存；3、 计算机的CPU不直接从主存中读取数据，CPU读取数据时，先把主存的数据读到Cache缓存中，然后再把Cache缓存中的数据读到寄存器中；4、 JVM中共享的数据可能会被分配到寄存器中，每个CPU都有自己的寄存器，一个CPU不能读取其他CPU的寄存器如果两个线程分别运行在不同的处理器（CPU）上，而这个共享的数据被分配到寄存器上，会产生可见性问题；5、 即使JVM中共享的数据分配到主存中，也不能保证数据的可见性CPU不直接对主存进行访问，而是通过Cache高速缓存来读取数据一个处理器上运行的线程对数据的更新，只是更新到写缓冲器中，还没有到达高速缓存中，更不用说主内存了；6、 一个处理器不能直接读取另一个处理器的Cache，但是可以通过缓存一致性协议（CacheCoherenceProtocol）来读取，并将读取到的数据更新到自己的Cache中，这个过程称为缓存同步；","tags":["Java","多线程，基础"],"categories":["Java","多线程","基础"]},{"title":"大数据之学习路线","path":"/2025/09/22/Big-Data-Learning/","content":"转自【硬刚大数据之学习路线篇】2021年从零到大数据专家的学习指南(全面升级版) 本博客的目的是总结出自己的学习大数据的路线，以便以后复习。以下是文章的主要内容： 第一部分：学习路径概览篇 第二部分：学习路径拆分篇 第三部分：视频学习资源推荐篇 第四部分：面试篇 第五部分：未来趋势在2019年9月份的时候，我写过一篇文章《剑谱总纲 | 大数据方向学习面试知识图谱》。 站在2019年的视角来看，应该成为了2019年我写的在CSDN平台最受欢迎的文章之一。 又过了两年，站在一个新的起点上。疫情突袭，反全球化浪潮迭起加之国内流量见顶，各大公司之间开启了白热化竞争。加之国家十四五规划出台，国家把信息科技作为了未来5-10年的核心发展方向，对我们传统的数据人提出了新的要求。 就像我在《大数据方向另一个十年开启》一文中所说，现在的大数据行业细分也秉持了10年的刚刚出现的时候的姿态一直在向前发展，未来可能有些方向会慢慢消亡，或者从传统的定义进化。 比如传统的BI岗位，这个岗位已经开始慢慢在消亡，和传统的离线数据仓库实时数据仓库进行了有机的融合。再比如，原来有个岗位叫做 ETL，也慢慢要淡出大家视野了，因为技能的局限性和可替代性太强？ 最近的一年来，Flink社区仍然保持比较旺盛的活力，更多的原因是因为社区的推动，与开发者不过是个工具，与阿里是技术影响力和商业化考量。 数据湖方向发展方兴未艾，都想攀上Flink社区的大树。未来谨慎看好吧，因为并未给一家业务主导的公司带来实质性的改变。 最近Apache社区停更了Sqoop，阿帕奇社区的几个项目在阶段性的完成了它的使命后最终都落幕了。比如刚刚停更的Sqoop，可能还有些同学在用的Kettle，还有我很早接触过的一个Falcon，它们早就该消失在历史的滚滚洪流中了。 自今年4月1日起，Apache软件基金会宣布将至少19个开源项目撤回到他们的Attic，其中13个与大数据相关，10个属于Hadoop生态系统。这种事情的发生基本也可以宣布大数据领域的黄金十年(2010-2020年)结束了。 第一部分：学习路径概览篇 编程语言计算机专业的同学的第一门语言大都是C语言，然后是面向对象的Java。除此之外，可以学习Scala和Python。Java是大数据领域的屠龙刀，适合集团化大规模作战。对Java的要求没有上限，越熟悉越好。Python更像一把锋利的匕首，更适用于短兵相接和贴身肉搏，用来写各种脚本。另外，这里特别提醒大家对于Go这门语言的关注。 随着云原生的发展，Java正受到Go、Rust等新兴语言的挑战，部分组件因为Cloud Native的发展可能在某一个领域会被慢慢替换掉。例如大名鼎鼎的Logstash，因为资源占用的原因，被用Golang的Filebeat代替了Shipper部分的职能。 Linux基础需要掌握基于Linux系统下的常用命令和常见问题诊断。 数据库入门基于MySQL了解常见的SQL语法，大数据领域SQL化是未来的发展方向。 计算机基础即计算机网络，操作系统，数据结构，计算机组成原理，这几门课非常重要的，虽然大多是纯理论知识，但是这都是底层，校招时，大厂都会问的。 对于计算机基础课，我找了一下读书的时候看过的视频和资源，后面还有工作中看的视频，稍有不同：1、操作系统 Operating System 学堂在线上清华的操作系统 哈工大李治军老师的操作系统 2、数据结构浙大陈越姥姥和何应钦老师讲的 数据结构。清华邓俊辉老师的数据结构，分为上下两篇： 数据结构(上) 数据结构(下) 3、计算机网络 哈工大计算机网络 4、计算机组成原理 计算机组成原理（上） 计算机组成原理（下) 这部分的内容非常多，需要抓住重点： 计算机网络（OSI七层模型或TCPIP五层模型） 数据结构（数组、栈、队列、链表、树） 算法（排序算法、查找算法、去重算法，最优解算法，LeetCode 算法题） 操作系统（进程、线程、IO、调度、内存管理） 好了！假如以上的计算机基础你全部掌握了。那么就可以进入大数据领域的正式学习了。 5.语言基础篇 语言基础 锁 多线程 并发包中常用的并发容器（J.U.C） JVM NIO RPC 6.分布式理论篇 分布式中的一些基本概念：集群（Cluster）、负载均衡（Load Balancer）等 分布式系统理论基础：一致性、2PC 和 3PC 分布式系统理论基础：CAP 分布式系统理论基础：时间、时钟和事件顺序 分布式系统理论进阶：Paxos 分布式系统理论进阶：Raft、Zab 分布式系统理论进阶：选举、多数派和租约 分布式锁的解决方案 分布式事务的解决方案 分布式 ID 生成器解决方案 7.网络通信篇 Netty 三层网络架构：Reactor 通信调度层、职责链 PipeLine、业务逻辑处理层 Netty 的线程调度模型 序列化方式 链路有效性检测 流量整形 优雅停机策略 Netty 对 SSLTLS 的支持 等等 8.离线计算篇 MapReduce HDFS YARN Hive Hbase 9.消息队列篇 Kafka 了解Pulsar 10.实时计算篇 Spark Flink 十分了解实时计算方向领域内的实时数据仓库、实时计算等的技术选型、架构设计、疑难杂症的排查。11.数据仓库数据湖 数仓理论：范式、分层模型等 数据仓库常见的问题：数据治理、元数据管理等 数据湖理论和架构、用到的框架(Hudi、IceBerg)等 12.算法篇 常见的大数据领域的算法：倒排、TopN、布隆过滤、字典树等 了解常见的机器学习算法 了解算法工程化 13.不可缺少的后端技能 Spring Mybatis SpringBoot … 以及后端常见的一些接口抽象、分层设计和架构设计(DDD领域驱动，MVC等)14.业务理解 基于当前业务的技术选型、成本控制、ROI投入产出比等 第二部分：学习路径拆分篇2.1. 语言基础篇语言基础整个大数据开发技术栈我们从实时性的角度来看，主要包含了离线计算和实时计算两大部分，而整个大数据生态中的框架绝大部分都是用 Java 开发或者兼容了 Java 的 API 调用，那么作为基于 JVM 的第一语言 Java 就是我们绕不过去的坎，Java 语言的基础也是我们阅读源码和进行代码调优的基础。Java 基础主要包含以下部分： Java 的面向对象 Java 语言的三大特征：封装、继承和多态 Java 语言数据类型 Java 的自动类型转换，强制类型转换 String 的不可变性，虚拟机的常量池，String.intern() 的底层原理 Java 语言中的关键字：final、static、transient、instanceof、volatile、synchronized的底层原理 Java 中常用的集合类的实现原理：ArrayListLinkedListVector、SynchronizedListVector、HashMapHashTableConcurrentHashMap 互相的区别以及底层实现原理 枚举 IO 反射 注解 Lambda表达式 动态代理 锁 CAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor 锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁 死锁的原因 死锁的解决办法 CountDownLatch、CyclicBarrier 和 Semaphore 三个类的使用和原理 多线程 并发和并行的区别 线程与进程的区别 线程的实现、线程的状态、优先级、线程调度、创建线程的多种方式、守护线程 自己设计线程池、submit() 和 execute()、线程池原理 为什么不允许使用 Executors 创建线程池 死锁、死锁如何排查、线程安全和内存模型的关系 ThreadLocal 变量 Executor 创建线程池的方式： ThreadPoolExecutor 创建线程池、拒绝策略 线程池关闭的方式 跟线程安全相关： 线程安全 多级缓存和一致性 CPU的时间片和原子性 指令重排序 内存模型 Happens-before as-if-serial 并发（J.U.C） 同步容器与并发容器(⭐️⭐️⭐️⭐️) JUC 包中 List 接口的实现类：CopyOnWriteArrayListJUC 包中 Set 接口的实现类：CopyOnWriteArraySet、ConcurrentSkipListSetJUC 包中 Map 接口的实现类：ConcurrentHashMap、ConcurrentSkipListMapJUC包中Queue接口的实现类：ConcurrentLinkedQueue、ConcurrentLinkedDeque、ArrayBlockingQueue、LinkedBlockingQueue、LinkedBlockingDeque Thread(⭐️⭐️⭐️⭐️⭐️) RunnableCallable(⭐️⭐️⭐️⭐️⭐️) ReentrantLock(⭐️⭐️⭐️⭐️⭐️) ReentrantReadWriteLock(⭐️⭐️⭐️⭐️⭐️) Atomic包(⭐️⭐️⭐️⭐️) Semaphore(⭐️⭐️⭐️⭐️) CountDownLatch(⭐️⭐️⭐️⭐️) ConcurrentHashMap(⭐️⭐️⭐️⭐️⭐️) Executors(⭐️⭐️⭐️⭐️⭐️) 以及Java并发包下的其他内容。JVM JVM 内存结构 堆和栈 Java 内存模型 垃圾回收GC算法：标记清除、引用计数、复制、标记压缩、分代回收、增量式回收GC参数垃圾收集器（CMS、G1、ZGC、Epsilon）对象存活的判定 JVM 参数及调优 Java 对象模型 虚拟机性能监控与故障处理工具 即时编译器、编译优化 类加载机制 虚拟机性能监控与故障处理工具jpsjstackjmapjstatjconsolejinfojhatjavapbtraceTProfilerjlinkArthas NIO 用户空间以及内核空间 Linux 网络 IO 模型：阻塞 IO (Blocking IO)、非阻塞 IO (Non-Blocking IO)、IO 复用（IO Multiplexing）、信号驱动的 IO (Signal Driven IO)、异步 IO 灵拷贝（ZeroCopy） BIO、AIO、NIO 对比 缓冲区 Buffer 通道 Channel 反应堆 Reactor 选择器 Selector epoll RPC RPC 的原理编程模型 常用的 RPC 框架：Thrift、Dubbo、SpringCloud RPC 的应用场景和与消息队列的差别 RPC 核心技术点：服务暴露、远程代理对象、通信、序列化 2.2. Linux基础Linux基础 基本指令 系统和网络命令 权限模型 基础的Shell脚本 2.2. 分布式理论篇 分布式中的一些基本概念：集群（Cluster）、负载均衡（Load Balancer）等 分布式系统理论基础：一致性、2PC 和 3PC 分布式系统理论基础：CAP 分布式系统理论基础：时间、时钟和事件顺序 分布式系统理论进阶：Paxos 分布式系统理论进阶：Raft、Zab 分布式系统理论进阶：选举、多数派和租约 分布式锁的解决方案 分布式事务的解决方案 分布式 ID 生成器解决方案 2.3.网络通信NettyNetty 是当前最流行的 NIO 框架，Netty 在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，业界著名的开源组件只要涉及到网络通信，Netty 是最佳的选择之一。 关于 Netty 我们要掌握： Netty 三层网络架构：Reactor 通信调度层、职责链 PipeLine、业务逻辑处理层 Netty 的线程调度模型 序列化方式 链路有效性检测 流量整形 优雅停机策略 Netty 对 SSLTLS 的支持 Netty的部分源码阅读举例：Netty 的 BufferNetty 的 ReactorNetty 的 PipelineNetty 的 HandlerNetty 的 ChannelHandlerNetty 的 LoggingHandlerNetty 的 TimeoutHandlerNetty 的 CodecHandlerNetty 的 MessageToByteEncoder ByteBuf TCPIP粘包拆包 编解码器 零拷贝、内存池设计 2.4.离线计算Hadoop 体系是我们学习大数据框架的基石，尤其是 MapReduce、HDFS、Yarn 三驾马车基本垫定了整个数据方向的发展道路。也是后面我们学习其他框架的基础，关于 Hadoop 本身我们应该掌握哪些呢？ MapReduce 掌握 MapReduce 的工作原理 能用 MapReduce 手写代码实现简单的 WordCount 或者 TopN 算法 掌握 MapReduce Combiner 和 Partitioner的作用 熟悉 Hadoop 集群的搭建过程，并且能解决常见的错误 熟悉 Hadoop 集群的扩容过程和常见的坑 如何解决 MapReduce 的数据倾斜 Shuffle 原理和减少 Shuffle 的方法 HDFS 十分熟悉 HDFS 的架构图和读写流程 十分熟悉 HDFS 的配置 熟悉 DataNode 和 NameNode 的作用 NameNode 的 HA 搭建和配置，Fsimage 和 EditJournal 的作用的场景 HDFS 操作文件的常用命令 HDFS 的安全模式 Yarn Yarn 的产生背景和架构 Yarn 中的角色划分和各自的作用 Yarn 的配置和常用的资源调度策略 Yarn 任务资源调度的过程 Hadoop3.0新特性 Erasure Coding HDFS数据冗余存储策略 1. 最低要求的Java版本从Java 7增加到Java 8现在，已针对Java 8的运行时版本编译了所有Hadoop JAR。仍在使用Java 7或更低版本的用户必须升级到Java 8。1. 支持HDFS中的纠删码纠删码是一种持久存储数据的方法，可节省大量空间。与标准HDFS副本机制的3倍开销相比，像Reed-Solomon(10,4) 这样的标准编码的空间开销是1.4倍。由于纠删码在重建期间会带来额外的开销，并且大多数情况下会执行远程读取，因此传统上已将其用于存储较冷，访问频率较低的数据。在部署此功能时应考虑纠删码机制的网络和CPU开销。3. Shell脚本重写Hadoop Shell脚本已被重写，以修复许多长期存在的错误并包括一些新功能。Hadoop的开发人员尽管一直在寻求兼容性，但是某些更改可能会破坏现有的安装。4. MapReduce 任务本地优化MapReduce 增加了对 map output 收集器的本地执行的支持，对于 shuffle 密集型工作，这可以使性能提高30％或更多。5. 支持两个以上的 NameNode在之前的版本中，HDFS的高可用最多支持两个NameNode。在HDFS 3.x 版本中，通过将编辑复制到法定数量的三个JournalNode，该体系结构能够容忍系统中任何一个节点的故障。但是，某些部署需要更高的容错度。这个新特性启用了这一点，该功能允许用户运行多个备用NameNode。例如，通过配置三个NameNode和五个JournalNode，群集可以忍受两个节点的故障，而不仅仅是一个节点的故障。6. 多个服务的默认端口已更改以前，多个Hadoop服务的默认端口在Linux临时端口范围内（32768-61000）。这意味着在启动时，服务有时会由于与另一个应用程序的冲突而无法绑定到端口。这些冲突的端口已移出临时范围，具体的端口更改如下：NameNode 的端口: 50070 -- 9870, 8020 -- 9820, 50470 -- 9871;Secondary NameNode 的端口: 50091 -- 9869, 50090 -- 9868;DataNode 的端口: 50020 -- 9867, 50010 -- 9866, 50475 -- 9865, 50075 -- 9864;Hadoop KMS 的端口: 16000 -- 9600（HBase的HMaster端口号与Hadoop KMS端口号冲突。两者都使用16000，因此 Hadoop KMS 更改为9600）。7. 支持Microsoft Azure数据湖和阿里云对象存储系统文件系统连接器Hadoop现在支持与Microsoft Azure数据湖和Aliyun对象存储系统集成，作为与Hadoop兼容的替代文件系统。8. 数据内节点平衡器单个DataNode可管理多个磁盘。在正常的写操作过程中，磁盘将被均匀填充。但是，添加或替换磁盘可能会导致DataNode内部出现严重偏差。原有的HDFS平衡器无法处理这种情况。新版本的HDFS中有平衡功能处理，该功能通过hdfs diskbalancer CLI调用。9. 基于HDFS路由器的联合基于HDFS路由器的联合添加了一个RPC路由层，该层提供了多个HDFS名称空间的联合视图。这简化了现有HDFS客户端对联合群集的访问。10. YARN资源类型YARN资源模型已被通用化，以支持用户定义的CPU和内存以外的可计数资源类型。例如，集群管理员可以定义资源，例如GPU，软件许可证或本地连接的存储。然后可以根据这些资源的可用性来调度YARN任务。 HiveHive 是一个数据仓库基础工具，在 Hadoop 中用来处理结构化数据。它架构在 Hadoop 之上，总归为大数据，并使得查询和分析方便。Hive 是应用最广泛的 OLAP 框架。Hive SQL 也是我们进行 SQL 开发用的最多的框架。 关于 Hive 你必须掌握的知识点如下： HiveSQL 的原理：我们都知道 HiveSQL 会被翻译成 MapReduce 任务执行，那么一条 SQL 是如何翻译成 MapReduce 的？ Hive 和普通关系型数据库有什么区别？ Hive 支持哪些数据格式 Hive 在底层是如何存储 NULL 的 HiveSQL 支持的几种排序各代表什么意思（Sort ByOrder ByCluster ByDistrbute By） Hive 的动态分区 HQL 和 SQL 有哪些常见的区别 Hive 中的内部表和外部表的区别 Hive 表进行关联查询如何解决长尾和数据倾斜问题 HiveSQL 的优化（系统参数调整、SQL 语句优化） 列式数据库 Hbase我们在提到列式数据库这个概念的时候，第一反应就是 Hbase。HBase 本质上是一个数据模型，类似于谷歌的大表设计，可以提供快速随机访问海量结构化数据。它利用了 Hadoop 的文件系统（HDFS）提供的容错能力。它是 Hadoop 的生态系统，提供对数据的随机实时读写访问，是 Hadoop 文件系统的一部分。我们可以直接或通过 HBase 的存储 HDFS 数据。使用 HBase 在 HDFS 读取消费随机访问数据。 HBase 在 Hadoop 的文件系统之上，并提供了读写访问。HBase 是一个面向列的数据库，在表中它由行排序。表模式定义只能列族，也就是键值对。一个表有多个列族以及每一个列族可以有任意数量的列。后续列的值连续地存储在磁盘上。表中的每个单元格值都具有时间戳。总之，在一个 HBase：表是行的集合、行是列族的集合、列族是列的集合、列是键值对的集合。 关于 Hbase 你需要掌握： Hbase 的架构和原理 Hbase 的读写流程 Hbase 有没有并发问题？Hbase 如何实现自己的 MVVC 的？ Hbase 中几个重要的概念：HMaster、RegionServer、WAL 机制、MemStore Hbase 在进行表设计过程中如何进行列族和 RowKey 的设计 Hbase 的数据热点问题发现和解决办法 提高 Hbase 的读写性能的通用做法 HBase 中 RowFilter 和 BloomFilter 的原理 Hbase API 中常见的比较器 Hbase 的预分区 Hbase 的 Compaction Hbase 集群中 HRegionServer 宕机如何解决 Hbase中的重要数据结构：LSM树、SkipList、布隆过滤器 2.5.消息队列篇Kafka 是最初由 Linkedin 公司开发，是一个分布式、支持分区的（partition）、多副本的（replica）的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于 Hadoop 的批处理系统、低延迟的实时系统、Spark 流式处理引擎，Nginx 日志、访问日志，消息服务等等，用 Scala 语言编写，Linkedin 于 2010 年贡献给了 Apache 基金会并成为顶级开源项目。 Kafka 或者类似 Kafka 各个公司自己造的消息’轮子’已经是大数据领域消息中间件的事实标准。Kafka 不满足单纯的消息中间件，也正朝着平台化的方向演进。 关于 Kafka 我们需要掌握： Kafka 的特性和使用场景 Kafka 中的一些概念：Leader、Broker、Producer、Consumer、Topic、Group、Offset、Partition、ISR Kafka 的整体架构 Kafka 选举策略 Kafka 读取和写入消息过程中都发生了什么 Kakfa 如何进行数据同步（ISR） Kafka 实现分区消息顺序性的原理 消费者和消费组的关系 消费 Kafka 消息的 Best Practice（最佳实践）是怎样的 Kafka 如何保证消息投递的可靠性和幂等性 Kafka 消息的事务性是如何实现的 如何管理 Kafka 消息的 Offset Kafka 的文件存储机制 Kafka 是如何支持 Exactly-once 语义的 通常 Kafka 还会要求和 RocketMQ 等消息中间件进行比较 Pulsar(⭐️⭐️⭐️)Pulsar的核心概念 复制 Topic Bookie Broker Entry Ledger MetaData Storage Journal 等等 Pulsar的关键特性 跨地域复制（ geo-replication），单个实例原生支持多个集群（跨集群复制） 极低的发布延迟和端到端延迟 可无缝扩展到超过一百万个 topic 简单的客户端API，支持Java、Go、Python和C++ 支持多种topic订阅模式：独占订阅、共享订阅、故障转移订阅、键共享（exclusive, shared, failover, key_shared） 通过 Apache BookKeeper 提供的持久化消息存储机制保证消息传递 由轻量级的无服务器（serverless ）计算框架 Pulsar Functions 实现流原生的数据处理 基于 Pulsar Functions 的无服务器连接器框架 Pulsar IO 使得数据更易移入、移出 Apache Pulsar 分层式存储可在数据陈旧时，将数据从热存储卸载到冷长期存储（如S3、GCS）中 Pulsar的架构设计一个Pulsar实例由一个或多个Pulsar集群组成。实例中的集群可以在它们之间复制数据。一个Pulsar cluster由三部分组成： 一个或者多个 broker ：负责处理和负载均衡 producer 发出的消息，并将这些消息分派给 consumer；Broker 与 Pulsar 配置存储交互来处理相应的任务，并将消息存储在 BookKeeper 实例中（又称 bookies）；Broker 依赖 ZooKeeper 集群处理特定的任务； 一个BookKeeper：包含一个或多个 bookie 的 BookKeeper 集群负责消息的持久化存储； 一个ZooKeeper：特定于某个Pulsar集群的ZooKeeper集群处理Pulsar集群之间的协调任务。 2.6.实时计算篇Spark 是专门为大数据处理设计的通用计算引擎，是一个实现快速通用的集群计算平台。它是由加州大学伯克利分校 AMP 实验室开发的通用内存并行计算框架，用来构建大型的、低延迟的数据分析应用程序。它扩展了广泛使用的 MapReduce 计算模型。高效的支撑更多计算模式，包括交互式查询和流处理。Spark 的一个主要特点是能够在内存中进行计算，即使依赖磁盘进行复杂的运算，Spark 依然比 MapReduce 更加高效。 Spark发展至今，应该说已经非常成熟了。是大数据计算领域不得不学习的框架。尤其是Spark在稳定性和社区发展的成熟度方面，基本可以吊打其他的大数据处理框架。Spark 生态包含了：Spark Core、Spark Streaming、Spark SQL、Structured Streming 和机器学习相关的库等。 假如你是第一次接触Spark，那么你需要对Spark的设计思想有所了解，知道Spark用了哪些抽象，Spark在提出RDD的时候是基于什么样的考虑。 在这里给大家推荐几篇论文如下： 第一篇：《弹性分布式数据集：一种为内存化集群计算设计的容错抽象》这篇文章中提出了弹性分布式数据集(RDD，Resilient Distributed Datasets)这个概念，这个概念是贯穿Spark设计的始终，是Spark最重要的概念之一。RDD是一种分布式的内存抽象，允许在大型集群上执行基于内存的计算(In-Memory Computing)，与此同时还保持了MapReduce等数据流模型的容错特性。 这篇文章中提到，Spark实现RDD在迭代计算方面比Hadoop快二十多倍，同时还可以在5-7秒的延时内交互式地查询1TB的数据集。 第二篇：《大型集群上的快速和通用数据处理架构》。因为这个文章长达170多页，堪比一篇博士论文。相信绝大多数人都是没兴趣读完的。我在这里给出一个读后小总结 这本书是Spark框架设计者–计算机科学博士Matei Alexandru Zaharia和加州大学伯克利分校教授、主席Scott Shenker撰写的。书中作者主要分析了当前流行的各种计算框架的使用场景以及他们对应的缺点，然后谈了下为什么编写了Spark这个框架和spark每个模块详细的设计理念及运行原理，这里是做一部分摘要。随着现在需要处理的数据量越来越大，单机处理要向集群进行扩展，这就会带来三个集群维度上的问题1)并行化：多个节点同时进行数据处理2)容错：在多节点上处理数据，节点的故障和慢节点会变得非常常见3)资源的动态分配：一般集群都是在多个用户之前进行切换，所以资源的动态扩展和缩减就变得非常重要。和MapReduce对比 MapReduce做为计算引擎与Spark的区别在于：Spark RDD在并行计算阶段之间能够高效的共享数据。MapReduce计算模型中，map结果必须要从内存落到磁盘，然后reduce再将数据加载到内存中，得到的结果再次落到磁盘中；如果是多个MapReduce操作数据，那么reduce结果数据还要再次加载到下一个map内存。正是由于数据一次次从磁盘加载到内存，所以MapReduce才会异常的慢。这也是Spark和MapReduce的区别，Spark RDD能够将数据cache到内存中，省去了从磁盘加载的过程，同时Spark shuffle过程中的数据也是直接放在内存中的(为了避免shuffle失败map数据丢失Spark框架还对shuffle进行了checkpoint)，这就是为什么spark比MapReduce块的原因。Spark解决的核心问题也就是数据流模型在计算过程中高效的共享数据 。RDD具有可容错和并行数据结构特征，这使得用户可以指定数据存储到硬盘还是内存、控制数据的分区方法并在数据集上进行种类丰富的操作。容错 一般的框架有两种容错方式,提供容错性的方法就要么是在主机之间复制数据,要么对各主机的更新情况做日志记录。第一种容错的方式恢复时间短但需要消耗更多的内存和磁盘空间用来存储数据。第二种方式不需要额外内存但是恢复时间比较长。这两种方法对于数据密集型的任务来说代价很高，因为它们需要在带宽远低于内存的集群网络间拷贝大量的数据，同时还将产生大量的存储开销。与上述系统不同的是，RDD提供一种基于粗粒度变换（如， map, filter, join）的接口，该接口会将相同的操作应用到多个数据集上。这使得他们可以通过记录用来创建数据集的变换（lineage），而不需存储真正的数据，进而达到高效的容错性。当一个RDD的某个分区丢失的时候，RDD记录有足够的信息记录其如何通过其他的RDD进行计算，且只需重新计算该分区。因此，丢失的数据可以被很快的恢复，而不需要昂贵的复制代价。RDD RDD是一个分区的只读记录的集合，用户可以控制RDD的其他两个方面：持久化和分区。用户可以选择重用哪个RDD，并为其制定存储策略(比如，内存存储)，也可以让RDD中的数据根据记录的key分布到集群的多个机器，这对位置优化来说是有用的，比如可用来保证两个要Jion的数据集都使用了相同的哈希分区方式。默认情况下，Spark会将调用过persist的RDD存在内存中。但若内存不足，也可以将其写入到硬盘上。通过指定persist函数中的参数，用户也可以请求其他持久化策略并通过标记来进行persist，比如仅存储到硬盘上，又或是在各机器之间复制一份。最后，用户可以在每个RDD上设定一个持久化的优先级来指定内存中的哪些数据应该被优先写入到磁盘。RDD的第一个优点是可以使用lineage恢复数据，不需要检查点的开销，此外，当出现失败时，RDDs的分区中只有丢失的那部分需要重新计算，而且该计算可在多个节点上并发完成，不必回滚整个程序 RDD的第二个优点是，不可变性让系统像MapReduce那样用后备任务代替运行缓慢的任务来减少缓慢节点 (stragglers) 的影响 在RDDs上的批量操作过程中，任务的执行可以根据数据的所处的位置来进行优化，从而提高性能，其次，只要所进行的操作是只基于扫描的，当内存不足时，RDD的性能下降也是平稳的。不能载入内存的分区可以存储在磁盘上，其性能也会与当前其他数据并行系统相当。RDDS最适合对数据集中所有的元素进行相同的操作的批处理类应用。RDDS不太适用于通过异步细粒度更新来共享状态的应用，比如针对Web应用或增量网络爬虫的存储系统.宽窄依赖 窄依赖允许在单个集群节点上流水线式执行，这个节点可以计算所有父级分区 。相反，宽依赖需要所有的父RDD数据可用并且数据已经通过类MapReduce的操作shuffle完成 其次，在窄依赖中，节点失败后的恢复更加高效。因为只有丢失的父级分区需要重新计算，并且这些丢失的父级分区可以并行地在不同节点上重新计算。与此相反，在宽依赖的继承关系中，单个失败的节点可能导致一个RDD的所有先祖RDD中的一些分区丢失，导致计算的重新执行。Spark的调度器会额外考虑被持久化(persist)的RDD的那个分区保存在内存中并可供使用，当用户对一个RDD执行Action(如count 或save)操作时，调度器会根据该RDD的lineage，来构建一个由若干 阶段(stage) 组成的一个DAG(有向无环图)以执行程序，每个stage都包含尽可能多的连续的窄依赖型转换。各个阶段之间的分界则是宽依赖所需的shuffle操作，或者是DAG中一个经由该分区能更快到达父RDD的已计算分区。之后，调度器运行多个任务来计算各个阶段所缺失的分区，直到最终得出目标RDD。调度器向各机器的任务分配采用延时调度机制并根据数据存储位置(本地性)来确定。若一个任务需要处理的某个分区刚好存储在某个节点的内存中，则该任务会分配给那个节点。否则，如果一个任务处理的某个分区，该分区含有的RDD提供较佳的位置(例如，一个HDFS文件)，我们把该任务分配到这些位置。对应宽依赖类的操作 {比如w shuffle依赖)，我们会将中间记录物理化到保存父分区的节点上。这和MapReduce物化Map的输出类似，能简化数据的故障恢复过程 对于执行失败的任务，只要它对应stage的父类信息仍然可用，它便会在其他节点上重新执行。如果某些stage变为不可用（例如，因为shuffle在map阶段的某个输出丢失了），则重新提交相应的任务以并行计算丢失的分区。(DAGscheduler官方定义) 若某个任务执行缓慢 (即”落后者”straggler)，系统则会在其他节点上执行该任务的拷贝。这与MapReduce做法类似，并取最先得到的结果作为最终的结果。Spark内存管理 Spark提供了三种对持久化RDD的存储策略：未序列化Java对象存于内存中、序列化后的数据存于内存及磁盘存储。第一个选项的性能表现是最优秀的，因为可以直接访问在JAVA虚拟机内存里的RDD对象。在空间有限的情况下，第二种方式可以让用户采用比JAVA对象图更有效的内存组织方式，代价是降低了性能。第三种策略适用于RDD太大难以存储在内存的情形，但每次重新计算该RDD会带来额外的资源开销。对于有限可用内存，我们使用以RDD为对象的LRU(最近最少使用)回收算法来进行管理。当计算得到一个新的RDD分区，但却没有足够空间来存储它时，系统会从最近最少使用的RDD中回收其一个分区的空间。除非该RDD便是新分区对应的RDD，这种情况下，Spark会将旧的分区继续保留在内存，防止同一个RDD的分区被循环调入调出。这点很关键–因为大部分的操作会在一个RDD的所有分区上进行，那么很有可能已经存在内存中的分区将会被再次使用。到目前为止，这种默认的策略在我们所有的应用中都运行很好， 当然我们也为用户提供了“持久化优先级”选项来控制RDD的存储。 大家可以看到，这些概念都是Spark中最最核心的几个概念。我们在学习过程中是万万绕不过去的。 第一张图是官方给出的Spark架构图，我们可以看到几个最重要的模块：Spark Core、Spark Streaming、Spark SQL。曾经还有一个部分叫做Structured Streaming，但是这部分好像慢慢被官方抛弃了，现在Spark官方主推SQL并且基于Spark SQL进行的优化和迭代非常之多。如果你是第一次接触Spark，并且业务没有特殊需要，可以暂时忽略Structured Streaming。此外Spark社区在努力的像机器学习和深度学习靠拢，Spark在完成最初的流计算目标后开始发力机器学习方向，如果有兴趣可以接触这一部分的内容。第二张图是一个简单的Spark快速学习的路线图，一些基本的Linux操作和运维基础，一点简单的搭建虚拟机的基础，我相信这些对大家来说都不是问题。然后我们就可以按照官网的demo进行第一次体验了：http:examples.htmlSpark的官网中给出了非常简单的Spark入门案例，同样我们也可以直接访问Spark在Github的仓库直接看更多的Demo：Spark在Github的仓库 关于Spark的书，我个人读了应该有4-5本，每本书都没有达到我的预期，如果说你真的需要一本书来当成工具，我觉得下面的书和Github项目可以用来参考：第一本书是：《大数据处理框架Apache Spark设计与实现》，这本书主要是介绍Spark的设计和原理，包含一部分源码。你可以把它当成一本八股文书来背，当然也可以当成一本指南来深入理解Spark的设计理念和深层次的原理。 这本书对应了一个Github的Repo：大数据处理框架Apache Spark设计与实现还有一本电子书：SparkSQL-Internal是关于Spark SQL的，这本书写的可谓用心良苦。对SparkSQL的发展历程和性能的优化、SparkSQL的使用方法、调优、架构、优化器Catalyst以及其他的各个模块都有详细介绍。除了上面的推荐书对应的repo，Github还有一个酷玩Spark：酷玩Spark这个仓库是由腾讯广告部的同学发起的，主要是Spark 源代码解析、Spark 类库等，源代码部分对Spark Streaming 和 Structured Streaming部分由非常深入的解释。但是这个仓库最后一次维护已经是2019年五月份。大家都知道2019年底Flink开源，可能抢了一部分热度，很多公司都开始转向对Flink的研究。 Spark至今只经历过1.x、2.x和3.x三个大版本的变化，在核心实现上，我们在Github能看到的最早的实现是0.5版本，这个版本只有1万多行代码，就把Spark的核心功能实现了。当然我们不可能从这么古老的版本看，假如你接触过Spark，现在准备看源码，那么我建议从2.x版本中选取一个，最好是2.3或者2.4。但是经过如此多的迭代，Spark的代码量已经暴增了几倍。关于Spark3.x中的新增功能和优化例如动态资源分配，可以针对性的进行补充即可。 学习 Spark 我们应该掌握：Spark Core Spark的集群搭建和集群架构（Spark 集群中的角色） Spark Cluster 和 Client 模式的区别 Spark 的弹性分布式数据集 RDD Spark DAG（有向无环图） 掌握 Spark RDD 编程的算子 API（Transformation 和 Action 算子） RDD 的依赖关系，什么是宽依赖和窄依赖 RDD 的血缘机制 Spark 核心的运算机制 Spark 的 CheckPoint 和容错 Spark 的通信机制 Spark Shuffle 原理和过程 Spark Streaming 原理剖析（源码级别）和运行机制 Spark Dstream 及其 API 操作 Spark Streaming 消费 Kafka 的两种方式 Spark 消费 Kafka 消息的 Offset 处理 数据倾斜的处理方案 Spark Streaming 的算子调优 并行度和广播变量 Shuffle 调优 Spark SQL Spark SQL 的原理和运行机制 Catalyst 的整体架构 Spark SQL 的 DataFrame Spark SQL 的优化策略：内存列式存储和内存缓存表、列存储压缩、逻辑查询优化、Join 的优化 Structured StreamingSpark 从 2.3.0 版本开始支持 Structured Streaming，它是一个建立在 Spark SQL 引擎之上可扩展且容错的流处理引擎，统一了批处理和流处理。正是 Structured Streaming 的加入使得 Spark 在统一流、批处理方面能和 Flink 分庭抗礼。 我们需要掌握： Structured Streaming 的模型 Structured Streaming 的结果输出模式 事件时间（Event-time）和延迟数据（Late Data） 窗口操作 水印 容错和数据恢复 Spark Mlib本部分是 Spark 对机器学习支持的部分，我们学有余力的同学可以了解一下 Spark 对常用的分类、回归、聚类、协同过滤、降维以及底层的优化原语等算法和工具。可以尝试自己使用 Spark Mlib 做一些简单的算法应用。 FlinkFlink框架自提出到实现，是有深厚的理论作为背书的，其中又以《Lightweight Asynchronous Snapshots for Distributed Dataflows》最为核心，本文提出了一种轻量级的异步分布式快照(Asynchronous Barrier Snapshot, 简称ABS)方法，既支持无环图，又支持有环图，而且可以做到线性扩展。 传统的流式计算由算子节点和连接算子的数据管道组成，传统的分布式快照方案就像拍照片一样，把每个算子内的state状态和彼此相连管道中的数据都保存下来。ABS方案的提出对传统的流式计算引擎的设计方案可以说是颠覆性的。 另外一篇是《Apache FlinkTM: Stream and Batch Processing in a Single Engine》，严格来说这篇论文是一篇Flink的概要设计文档。可以当成一个技术文档来看，对于很多我们难以理解的设计都有很大的帮助。 此外，《The world beyond batch: streaming 101102》是由Google的大神Tyler Akidau写的两篇文章。第1篇文章，在深入了解时间，对批处理和流式数据常见处理方式进行高阶阐述之前，介绍一些基本的背景知识和术语。第2篇文章主要介绍包括Google Dataflow大数据平台使用的统一批量+流式传输模式。这两篇文章对于我们理解Flink中的时间、窗口、触发器等等的实现有十分重要的指导意义。并且作者还在YouTube上传了动画，可谓用心良苦。 Apache Flink（以下简称 Flink）项目是大数据处理领域最近冉冉升起的一颗新星，其不同于其他大数据项目的诸多特性吸引了越来越多人的关注。尤其是 2019 年初 Blink 开源将 Flink 的关注度提升到了前所未有的程度。 那么关于 Flink 这个框架我们应该掌握哪些核心知识点？ Flink 集群的搭建 Flink 的架构原理 Flink 的编程模型 Flink 集群的 HA 配置 Flink DataSet 和 DataSteam API 序列化 Flink 累加器 状态 State 的管理和恢复 窗口和时间 并行度 Flink 和消息中间件 Kafka 的结合 Flink Table 和 SQL 的原理和用法 Flink CDC Flink和其他框架的Connector的原理和使用 Flink SQL中常见的问题 源码阅读部分： Flink 基本组件和逻辑计划：介绍了 Flink 的基本组件、集群构建的过程、以及客户端逻辑计划的生成过程 link 物理计划生成：介绍了 Flink JobManager 对逻辑计划的运行时抽象，运行时物理计划的生成和管理等 Jobmanager 基本组件和TaskManager的基本组件 Flink 算子的生命周期：介绍了 Flink 的算子从构建、生成、运行、及销毁的过程 Flink 网络栈：介绍了 Flink 网络层的抽象，包括中间结果抽象、输入输出管理、BackPressure 技术、Netty 连接等 Flink的水印和Checkpoint Flink-scheduler：介绍 Flink 的任务调度算法及负载均衡 Flink对用户代码异常处理：介绍作业的代码异常后 Flink 的处理逻辑，从而更好的理解 Flink 是如何保证了 exactly-once 的计算语义 Flink TableSQL 执行流程、Flink和Hive的集成等 2.8.数据调度数据交换数据治理、血缘等(⭐️⭐️⭐️⭐️)数据任务调度老牌调度框架Oozie、Azkaban、Airflow应用广泛，基于当前公司技术平台的选型情况掌握。这里我要着重提一下Apache DolphinScheduler这个框架，这个框架为国内开源项目,相对其他国外项目，有天然的本土优势，如果你还没有接触过任务调度框架，可以直接学习DolphinScheduler这个框架。 数据交换Kettle、DataX、Streamsets、SeaTunnel等异构数据交换工具，可以根据自己的业务需要选择一种学习和掌握。 数据治理数据治理是这两年数据领域兴起的一个小方向，尤其是一些传统企业在做数字化转型过程中需要很多懂数据治理的人才。你应该懂的内容包含： 数据治理的业务标准、技术标准、数据安全标准等 架构治理、模型治理、元数据治理 元数据采集、元模型构建、元数据服务、元数据应用 数据地图、数据可视化、数据质量监控 这部分内容大家可以直接参考阿里的OneData理论进行学习。 第一部分：OneModel 致力于实现数据的标准与统一。 第二部分：OneID 致力于实现实体的统一，让数据融通而非以孤岛存在，为精准的用户画像提供基础。 第三部分：OneService 致力于实现数据服务统一，让数据复用而非复制。 2.9.数据仓库数据湖 离线数据仓库 数据模型架构原则 数仓分层原则 主题域划分原则 数据模型设计原则 数仓公共开发规范 层次调用规范 数据类型规范 数据冗余规范 NULL字段处理规范 指标口径规范 数据表处理规范 表的生命周期管理 数仓各层开发规范 ODS层设计规范 公共维度层设计规范 DWD明细层设计规范 DWS公共汇总层设计规范 数仓命名规范 词根设计规范 表命名规范 指标命名规范 实时数据仓库 实时数据仓库架构选型：Lambda、Kappa、流批一体 实时数据体系架构分层 实时数据体系技术选型：接入、存储、计算、服务、应用 实时数据模型分层 数据仓库的高性能与管理能力，与数据湖的灵活性，仓和湖的两套体系在相互借鉴与 融合。在2020年各大公司分别提出湖仓一体架构，成为当下架构演进最热的趋势。但湖仓一体架构有多种形态，不同形态尚在演进和争论中。 这部分设计到Format层的数据选型包含：Hudi、IceBerg、Delta三个主要的框架。大家可以根据公司需要选择学习。 2.10.OLAP篇(⭐️⭐️⭐️⭐️)常见的OLAP数据库，这个部分因个人而异，看个人业务用到OLAP库，包括不限于： Hive、Hawq、Impala：基于 SQL on Hadoop Presto 和 Spark SQL 类似：基于内存解析 SQL 生成执行计划 Kylin：用空间换时间、预计算 Druid：数据实时摄入加实时计算 ClickHouse：OLAP领域的HBase，单表查询性能优势巨大 Greenpulm：OLAP领域的PostgreSQL包括如果你要做搜索还可能用到ElasticSearch这样的框架，根据个人业务需要学习。 2.11.算法 常见的大数据领域的算法：倒排、TopN、布隆过滤、字典树等 了解常见的机器学习算法 了解算法工程化 2.12.不可缺少的后端技能(⭐️⭐️⭐️⭐️) Spring Mybatis SpringBoot 常见的设计模式 第三部分：视频书籍推荐篇这部分我在之前的分类文章中会有推荐，如果有遗漏可以参考之前的各个分类下的文章。 万能的B站！Orz…操作系统 学堂在线上清华的操作系统 哈工大李治军老师的操作系统 参考链接：操作系统 数据结构与算法陈越何应钦Java版数据结构与算法 计算机网络哈工大计算机网络《计算机网络（自顶向下方法 第7版》 计算机组成原理哈工大计算机组成原理（上）哈工大计算机组成原理（下） 计算机专业应用 Java零基础入门 MySQL数据库 Linux教程 大数据Hadoop 2.x教程 Hive框架详解 Hbase教程 Kafka教程 Spark教程 Flink入门教程 实战项目 实战项目一 实战项目二 实战项目三 3.1.B站资源汇总语言基础篇关于编程语言这部分，大部分同学都是Java附带Scala技能加点，当然如果你学了一点Python的东西也是一个加分项。 那么关于Java语言你可以参考下面这个视频，尤其是如果你的语言基础极差，都没有用过Java语言。 《Java基础到高级-宋红康》 https://www.bilibili.com/video/BV1Qb411g7cz 如果你有一定的语言基础，想看看自己掌握到了什么程度？OK，下面这个视频就满足你的胃口了。这个视频从关键字到新特性，带着问题的形式，边学边考。 《最全Java零基础入门教程(含百道Java真题)》 https://www.bilibili.com/video/BV1Kb411W75N 数据结构篇如果你还在读书，结合课本来看，我推荐这个： 《数据结构-浙江大学》 https://www.bilibili.com/video/BV1JW411i731 浙江大学老师的这个视频可以说是公开课的牌面了，可以称为数据结构篇的「正规军」了。与之对应的是，下面这个视频。如果你工作有一段时间了，那么可以直接看这个视频： 《数据结构与算法(小甲鱼)》 https://www.bilibili.com/video/av29175690小甲鱼简直可以称为良心UP主的楷模。小甲鱼的视频语言风趣幽默，举了很多的例子配合知识点。 Linux基础Linux基础这块对于数据开发非常重要，因为大家平时接触过的数据框架的搭建过程涉及大量的Linux命令操作，并且在系统级别的调优还会接触atime、ulimit这种比较高级的命令。这里我推荐史上最牛的Linux视频教程： 《史上最牛的Linux视频教程—兄弟连》 https://www.bilibili.com/video/av18156598 如果这个视频满足不了你，你还可以参考： 《Linux教程(千万级学习人次)》 https://www.bilibili.com/video/av21303002 数据库入门基于MySQL了解常见的SQL语法，大数据领域SQL化是未来的发展方向。 《MySQL 基础+高级篇》 https://www.bilibili.com/video/av49181542 以及下面这个： 《MySQL最新教程通俗易懂》 https://www.bilibili.com/video/BV1NJ411J79W 计算机基础操作系统 这里B站是万能的，但是我还给出了一些其他的链接：学堂在线上清华的操作系统 https://www.xuetangx.com/course/THU08091000267/5883104哈工大李治军老师的操作系统 https://www.icourse163.org/course/HIT-1002531008#/info操作系统 参考链接：https://www.bilibili.com/video/BV1YE411D7nH 数据结构与算法 陈越何应钦的数据结构和算法公开课 https://www.icourse163.org/course/zju-93001#/info《Java版数据结构与算法》 参考链接：https://www.bilibili.com/video/BV1E4411H73v 计算机网络哈工大版本 参考链接：https://www.icourse163.org/course/hit-154005中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版》 参考链接：https://www.bilibili.com/video/BV1JV411t7ow 计算机组成原理哈工大计算机组成原理上：https://www.icourse163.org/course/hit-309001#/info 下：https://www.icourse163.org/course/hit-1001527001#/info 3.2.框架篇这部分就到了真正考验各个老师的水平阶段了。 离线部分必看的几个视频： 《Hadoop2.x框架入门教程》 https://www.bilibili.com/video/BV1cW411r7c5《大数据Hadoop3.x(全新升级部署+源码+实战)》 https://www.bilibili.com/video/BV1Qp4y1n7EN 当时看到3.x这个视频的时候，无哥我是虎躯一震。这也太强了，Hadoop3.x才出多久，这网上视频都有了？ HiveHive也是，这特么3.x版本才出来没多久。在下实在也是震惊了。关键这课的质量还挺好。 《Hive教程(基于Hive3.1.2)》 https://www.bilibili.com/video/BV1EZ4y1G7iL 如果上面的入门课程满足不了你，下面的这个进阶课相信可以填满你了。 《2021新版Hive高级进阶教程》 https://www.bilibili.com/video/BV1Cb4y1r7p2 Hbase如果你是一个初学者，那么可以看这个： HBase入门教程 https://www.bilibili.com/video/BV1Y4411B7jy 那么如果你是一个资深的开发，需要系统的学习或者查漏补缺，视频就满足不了大家了。这里我推荐一本书： 《HBase原理与实践》, 作者: 胡争、范欣欣 Kafka你可以参考这个视频： 《消息队列kafka快速入门》 https://www.bilibili.com/video/BV1a4411B7V9 Kafka这个框架更新也非常频繁，至今已经到了3.x版本了，并且引入了很多新的特性。目前还没有看到跟最新版本有关的视频出现。如果你的时间有限，可以看这个： 《B站讲的最好的Kafka视频教程全集》 https://www.bilibili.com/video/BV1eg411g7s3 Spark这个名字取得很大，但是当成一个入门课还是不错的。 《大数据Spark教程从入门到精通》 https://www.bilibili.com/video/BV11A411L7CK 同样大家也知道，Spark3.x版本的更新也带来了一波巨大的改变。 大数据Spark3.0教程 https://www.bilibili.com/video/BV11A411L7CK 就问你强不强! Flink再次给清华大佬跪下了。Flink的这个视频我在群里跟很多小伙伴推荐过了。此视频一出，B站吃瓜群众惊呼：武老师，发生甚么事了?! Java版Flink(武老师清华硕士，原IBM-CDL负责人) https://www.bilibili.com/video/BV1qy4y1q728 清华大佬不满足于此，竟然给Flink SQL出了单独的视频！ Flink SQL(武老师清华硕士，原IBM-CDL负责人) https://www.bilibili.com/video/BV12k4y1z7LM 3.3.项目实战篇 《大数据电商数仓V3.0版本教程》 https://www.bilibili.com/video/BV1Hp4y1z7aZ《实时数据仓库项目(阿里云实时数仓)》 https://www.bilibili.com/video/BV1dJ411k7BE《2021新版电商数仓V4.0丨大数据数据仓库项目实战》 https://www.bilibili.com/video/BV1rL411E7uz 3.4.社区篇我们来看一下简介： 阿里云开发者社区覆盖云计算、物联网、大数据、云原生、数据库、人工智能、微服务、安全、开发、运维等技术领域,集合阿里巴巴经济体各个单元技术优势。 阿里云开发者社区集合阿里巴巴经济体各个单元技术优势，提供分享、交流、学习、认证、工具、资源、大赛、活动、创业等一站式服务能力，满足开发者全生命周期成长需求。 大家不要觉得啰嗦，这个简介就是整个阿里云栖社区的最终定位。所有围绕云栖社区的建设都是基于这样的构想而进行的。 今天我们介绍的就是它的大数据板块，我们直接给出网址： https://developer.aliyun.com/community/bigdata在首页的左上角你可以看到更多的的子目录：如果你需要从大数据扩展到其他领域的学习，那么你能看到更多的板块，去对应板块寻找资源。你可以通过首页的「电子书」标签进入这个板块，这个板块又被称为「藏经阁」，这里面有非常多的电子书可以直接下载。包括「书架上新」「阿里精选」「技术实战」等板块。 这里的电子书质量非常高，比如整个Java开发领域奉为圭臬的「Java开发手册」，就出自这里。 这里面关于大数据的电子书也非常多，很多都是阿里云的专家进行的总结，深度远超任何博客。比如我经常看的「Redis最佳实践和实践指南」、「Apache Flink十大技术难点实战」等等，更多的书大家可以自己去找。在「藏经阁」下有一个栏目叫做「职业发展」，这里面的内容需要工作5年以内的开发要好好读一读，基于整个数据开发方向的技术栈和未来进阶的方向上的指引，这里已经有很多大佬总结好了。相信能给你解答很多困惑。比如你的问题是「如何计算pvuv」?，这样的问题很难回答，需要的前置条件太多，比如你是基于Spark还是基于Flink，你是实时统计还是SQL查询？所以大数据领域的问题一般都是方向性的。 这个板块的问题，大家可以好好看看。看看业界的做法一般都是什么样的。学习路线进阶区这个部分不在多言，如果你需要在某一个领域深造，那么首先方向不能错，否则一切都是徒劳的。这个板块不仅给出了学习路线，你学习完成后还可以测试一下你掌握的程度。也就是「技能自测」区，如下图： 这个就是大家最关注的一些圈子了。热度很高的圈子自然可能就是未来发展的重点，有时间不妨多跳出自己目前从事的这个方向，看看其他的圈子都在做什么。整个云栖社区的大数据板块还有非常多的宝藏区等待大家自己去发掘。整个云栖社区大数据体系，无论是从质量还是广度上，都远超其他任何博客的大数据板块。 第四部分：面试篇这部分你可以直接参考：​ ​《八千里路云和月 | 从零到大数据专家学习路径指南》​​的面试部分。 第一，硬条件、学校、学历。这部分不必多言，大家应该都懂。学校的牌子是你拿到一面的最好的招牌。 第二，比赛荣誉论文等这部分主要是在学校的一些论文、获奖、比赛等。这部分需要你突出你在学校的科研能力，这是证明你过去能力的最直接证明。 第三，计算机基础计算机基础包含计算机专业的基本主要的课程，也就是数据结构，计算机组成原理，计算机网络，操作系统。 此外你还需要刷上一些Leetcode题目保证自己的算法题能写出来。 还有就是你的语言基础，如果你是做OLAP数据库底层，那么可能要求C和C++基础，如果你去做Flink这样的中间件平台或者业务开发，那么就是Java的基础。懂了啵？ 第四，项目经验这部分主要是各位在学校实验室跟导师做的项目，以及你的实习经历。一份名企的实习经历是非常加分的。大家根据自己的情况去做一些实际项目吧。能实习最好，其次在实验室写一些项目也可以，最后实在不行就在B站找上几个学一下，参考:​ ​《我在B站读大学，大数据专业》​​。 第五部分：未来趋势大数据领域仍然处于发展期，部分技术收敛，但新方向和新领域层出不穷。阿里云计算平台事业部也推出了「后红海」时代的大数据的发展趋势。我把其中的观点详细列了出来： 近实时架构兴起在离线 batch 计算和纯流式实时计算之间，以开源 Apache DeltaHudi 为代表的近实时架构成为热点。近实时架构避免了流计算庞大的状态存储与管理，在成本和延迟上找到了另一个平衡。随近实时架构的形成，计算架构最终完成从离线到实时全频谱支持。 数据湖三巨头的持续发展给近实时架构的落地带来了可能性。数据湖方向也是需要大家密切关注的方向。 数据共享与隐私保护成为热点数据成为资产，开始具备可变现和可交易的能力。可保护隐私的数据交换共享能力成 为强劲的需求。基于 Differential Privacy 的数据编码交易，以及基于 Federated Learning的多方面安全计算是该领域的热点技术。 隐私计算是一类技术方案，在处理和分析计算数据的过程中能保持数据不透明、不泄露、无法被计算方法以及其他非授权方获取。 从技术角度出发，隐私计算是涵盖众多学科的交叉融合技术，目前主流的隐私计算技术主要分为三大方向： 第一类是以多方安全计算为代表的基于密码学的隐私计算技术； 第二类是以联邦学习为代表的人工智能与隐私保护技术融合衍生的技术； 第三类是以可信执行环境为代表的基于可信硬件的隐私计算技术。 不同技术往往组合使用，在保证原始数据安全和隐私性的同时，完成对数据的计算和分析任务。 IoT成为热点目前人的行为数据（日志）是大数据计算的主要来源，超过 80%的数据都来源于行为 日志（例如浏览、点击）。随 5G+智能化设备的兴起，设备日志会成为更大的数据源增长点，面向海量低价值设备数据的处理和优化，需要得到更多的关注。 Apache 软件基金会于北京时间2020年9月23日宣布Apache IoTDB毕业成为 Apache 顶级项目。 Apache IoTDB（物联网数据库）是一体化收集、存储、管理与分析物联网时序数据的软件系统。Apache IoTDB 采用轻量式架构，具有高性能和丰富的功能，并与Apache Hadoop、Spark和Flink等进行了深度集成，可以满足工业物联网领域的海量数据存储、高速数据读取和复杂数据分析需求。 如果未来你从事的是IoT方向，那么需要持续关注这个领域的发展。 AI for SystemAI for System，即大数据自动驾驶。AI 作为工具，成为优化的常用手段。在大数据领域，随数据量系统复杂度的增长，DBA 模式已经不再试用。利用算法优化系统成为主流方向，大数据的”自动驾驶”会越来越自动。 云原生和图计算根据阿里云关涛老师的一些观点: 数据库和数仓已经发展了 40 多年，主流的计算范式就是二维关系表达。近 10 年，深度学习带来了一个新的计算方式。那除此以外，还有没有一个更新一代的计算方式会产生？ 图计算是目前最被看好的方向，它是点边模型，与二维关系表达并不相同。但是数据库技术发展过程中也诞生了图计算模式，并且已经发展多年，但目前仍然不是主流。 随着图学习 GraphEmbedding 技术的兴起，图计算是否能焕发新生变成一个主流的计算范式也是值得大家关注的。 图计算领域的一些数据库可能是大家学习的重点，例如：Neo4j、JanusGraph、HugeGraph等。 而「云原生(Cloud Native)」在2021年在大数据与云计算领域牢牢占据了C位。数据显示，云原生计算基金会(CNCF)现在拥有 730 多个成员组织和 100 多个开源云原生项目，整个云原生生态逐步趋于完善。 云原生领域涵盖的技术类别越来越多，但最关键的三项是容器、Serverless、Service Mesh。其中以K8s为核心的容器技术需要大家持续关注。 总结时代在发展，旧的技术在消亡，例如Hadoop体系中一些不在活跃的项目，Mesos、Storm这样的框架。新的领域层出不穷，云原生(Cloud Native)、隐私计算、湖仓一体、IoT等等。 国内互联网领域持续被整治，各大公司麻烦不断。但是2021年也有非常多的新兴公司脱颖而出走近大家的视野，例如DataBricks、ClickHouse,Inc、Stream Native等等。 ©著作权归作者所有：来自51CTO博客作者蜡笔小新v的原创作品，请联系作者获取转载授权，否则将追究法律责任2022年全网首发|大数据专家级技能模型与学习指南(胜天半子篇)https://blog.51cto.com/u_9928699/5247264","tags":["大数据","学习路线"],"categories":["大数据","学习路线"]},{"title":"Spring原理","path":"/2025/09/13/Spring-Base/","content":"Spring 基础框架Spring 概述Spring是分层的Java SEEE应用full-stack轻量级开源框架,以**IoC ( Inverse Of Control:反转控制)和AOP (Aspect oriented Progr anming:面向切面编程)**为内核，提供了展现层SpringMVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。 Spring 优势 方便解耦，简化开发通过Spring提供的IoC容器,可以将对象间的依赖关系交由Spring 进行控制,避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 AOP编程的支持通过Spring的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。 声明式事务的支持可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。 方便程序的测试可以非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。 方便集成各种优秀框架Spring可以降低各种框架的使用难度,提供了对各种优秀框架(Struts、Hibernate. Hessian、Quartz等)的直接支持。 降低JavaEE API的使用难度Spring对JavaEE API (如JDBC、JavaMail、远程调用等)进行了薄薄的封装层，使这些API的使用难度大为降低。 Java源码是经典学习范例Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无疑是Java技术的最佳实践的范例 什么是程序耦合？我们在开发中，会写很多的类,而有些类之间不可避免的产生依赖关系,这种依赖关系称之为耦合。有些依赖关系是必须的，有些依赖关系可以通过优化代码来解除的。请看下面的示例代码: /** * 客户的业务层实现类 */public class CustomerService implements ICustormerService private ICustomerService custormerDao = new CustomerDaoImp(); 上面的代码表示:业务层调用持久层，并且此时业务层在依赖持久层的接口和实现类。如果此时没有持久层实现类，编译将不能通过。这种依赖关系就是我们可以通过优化代码解决的。 什么是控制反转？ 控制反转(Inversion of Control,缩写为IoC)，是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入(Dependency Injection,简称DI)，还有一种方式叫“依赖查找” (Dependency Lookup)。通过控制反转,对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。——摘自百度百科 Spring的体系结构Spring框架至今已集成了20多个模块，这些模块分布在以下模块中： 核心容器（Core Container） 数据访问集成（Data AccessIntegration）层 Web层 AOP（Aspect Oriented Programming）模块 植入（Instrumentation）模块 消息传输（Messaging） 测试（Test）模块 Spring的核心容器是其他模块建立的基础，有Spring-core、Spring-beans、Spring-context、Spring-context-support和Spring-expression（String表达式语言）等模块组成。 Spring-core模块：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。 Spring-beans模块：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。 Spring-context模块：建立在Core和Beans模块的基础之上，提供一个框架式的对象访问方式，是访问定义和配置的任何对象的媒介。ApplicationContext接口是Context模块的焦点。 Spring-context-support模块：支持整合第三方库到Spring应用程序上下文，特别是用于高速缓存（EhCache、JCache）和任务调度（CommonJ、Quartz）的支持。 Spring-expression模块：提供了强大的表达式语言去支持运行时查询和操作对象图。这是对JSP2.1规范中规定的统一表达式语言（Unified EL）的扩展。该语言支持设置和获取属性值、属性分配、方法调用、访问数组、集合和索引器的内容、逻辑和算术运算、变量命名以及从Spring的IOC容器中以名称检索对象。它还支持列表投影、选择以及常用的列表聚合。","tags":["java","Spring"]},{"title":"Java的设计模式","path":"/2025/09/11/Java-Design/","content":"第一章 学习设计模式的必要性设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。 正确使用设计模式具有以下优点： 可以提高程序员的思维能力、编程能力和设计能力。 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。 设计模式的分类 创建型模型用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。 结构型模式用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。 行为型模式用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。 第二章 创建者模式什么是创建者模式？创建型模式的主要关注点是怎样创建对象？，它的主要特点是将对象的创建与使用分离。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。创建型模式分类及详细教程如下： 单例模式单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 单例模式的实现单例设计模式分类两种： 饿汉式： 类加载就会导致该单实例对象被创建 适合在类的实例化代价较小或总是需要使用的情况下使用。 由于在类加载时就创建实例，因此不需要考虑线程安全问题。 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建 在类加载时就实例化对象，不管是否需要使用。 适合在实例化代价较大或不常用的情况下使用。 需要考虑线程安全问题，可能会导致多线程环境下的安全隐患。这两种模式各有优缺点，选择时需根据具体情况而定。 饿汉式-方式1 (静态变量方式)静态变量创建类的对象 public class Singleton //私有构造方法 private Singleton() ​ //在成员位置创建该类的对象 private static Singleton instance = new Singleton();​ //对外提供静态方法获取该对象 public static Singleton getInstance() return instance; 说明该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。 饿汉式-方式2 (静态代码块方式)静态代码块中创建类的对象 public class Singleton ​ //私有构造方法 private Singleton() ​ //在成员位置创建该类的对象 private static Singleton instance;​ static instance = new Singleton(); ​ //对外提供静态方法获取该对象 public static Singleton getInstance() return instance; 说明该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。 懒汉方式1–线程不安全/** * 懒汉式 * 线程不安全 */public class Singleton //私有构造方法 private Singleton() ​ //在成员位置创建该类的对象 private static Singleton instance;​ //对外提供静态方法获取该对象 public static Singleton getInstance() ​ if(instance == null) instance = new Singleton(); return instance; 说明从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。 解释下为什么会存在线程问题：假设现在有两个线程t1和t2同时调用getInstance() 方法，t1刚判断instance null为true进入内部吗，刚要进行创建，此时正好丢失CPU执行权，进入阻塞状态，而t2获得CPU执行权，也进行了instance null判断，发现也是true，就进入了内部代码进行创建，此时我们发现t1和t2都会执行内部的new代码，从而获得了两个不同的实例对象。 懒汉方式2–线程安全/** * 懒汉式 * 线程安全 */public class Singleton //私有构造方法 private Singleton() ​ //在成员位置创建该类的对象 private static Singleton instance;​ //对外提供静态方法获取该对象 public static synchronized Singleton getInstance() ​ if(instance == null) instance = new Singleton(); return instance; 说明该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。 懒汉式-方式3（双重检查锁）再来讨论一下懒汉模式中加锁的问题，对于 getInstance() 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式 /** * 双重检查方式 */public class Singleton ​ //私有构造方法 private Singleton() ​ private static Singleton instance;​ //对外提供静态方法获取该对象 public static Singleton getInstance() //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例 if(instance == null) synchronized (Singleton.class) //抢到锁之后再次判断是否为null if(instance == null) instance = new Singleton(); return instance; 双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。 要解决双重检查锁模式带来空指针异常的问题，只需要使用volatile关键字, volatile关键字可以保证可见性和有序性。在单例模式中，volatile关键字主要用于确保多线程环境下的可见性和禁止指令重排序。当一个类使用懒汉式的方式创建单例对象时，volatile 可以防止由于指令重排序导致的问题。通过使用volatile关键字，可以保证在多线程环境下对 instance 的可见性和防止指令重排序： /** 使用 volatile 防止指令重排 */public class Singleton private static volatile Singleton instance; private Singleton() public static Singleton getInstance() if (instance == null) synchronized (Singleton.class) if (instance == null) instance = new Singleton(); return instance; 在上面的代码中，将 instance 声明为 volatile 可以确保在一个线程修改了 instance 的值后，其他线程能够立即看到这个变化，避免了由于指令重排序而导致的问题。 这种方式通常称为双重检查锁定（Double-Checked Locking）机制，通过在内部的 if (instance null) 判断之前和之后都进行一次检查，以保证线程安全且效率较高。需要注意的是，这种方式要求 instance 被声明为 volatile。 小结添加volatile关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。 懒汉式-方式4（静态内部类方式）静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被static修饰，保证只被实例化一次，并且严格保证实例化顺序。 /** * 静态内部类方式 */public class Singleton ​ //私有构造方法 private Singleton() ​ private static class SingletonHolder private static final Singleton INSTANCE = new Singleton(); ​ //对外提供静态方法获取该对象 public static Singleton getInstance() return SingletonHolder.INSTANCE; 说明第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder 小结静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。 枚举方式枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。 /** * 枚举方式 */public enum Singleton INSTANCE; 枚举方式属于饿汉式方式。 两种破坏单例模式的场景及如何防止的代码演示前面我们演示了单例模式的多种Java代码的实现方式，虽然看上去完美无缺的，但是其实还是存在一定的问题的，在某些场景下，可以破坏单例模式，从而创建出来多个实例。接下来，我们一起看下破坏单例模式的两个场景，以及每个场景我们应该如何预防被破坏。 破坏单例模式两种场景使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。 序列化反序列化方式破坏单例模式演示Singleton类：(内部静态类构造单例对象) public class Singleton implements Serializable ​ //私有构造方法 -- 内部静态类 private Singleton() ​ private static class SingletonHolder private static final Singleton INSTANCE = new Singleton(); ​ //对外提供静态方法获取该对象 public static Singleton getInstance() return SingletonHolder.INSTANCE; Test类： public class Test public static void main(String[] args) throws Exception //往文件中写对象 //writeObject2File(); //从文件中读取对象 Singleton s1 = readObjectFromFile(); Singleton s2 = readObjectFromFile();​ //判断两个反序列化后的对象是否是同一个对象 System.out.println(s1 == s2); ​ private static Singleton readObjectFromFile() throws Exception //创建对象输入流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(C:\\\\Users\\\\Think\\\\Desktop\\\\a.txt)); //第一个读取Singleton对象 Singleton instance = (Singleton) ois.readObject();​ return instance; ​ public static void writeObject2File() throws Exception //获取Singleton类的对象 Singleton instance = Singleton.getInstance(); //创建对象输出流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(C:\\\\Users\\\\Think\\\\Desktop\\\\a.txt)); //将instance对象写出到文件中 oos.writeObject(instance); 上面代码运行结果是false，表明序列化和反序列化已经破坏了单例设计模式。 反射方式破坏单例模式演示Singleton类： public class Singleton ​ //私有构造方法 private Singleton() private static volatile Singleton instance;​ //对外提供静态方法获取该对象 -- 双重检查锁 public static Singleton getInstance() ​ if(instance != null) return instance; ​ synchronized (Singleton.class) if(instance != null) return instance; instance = new Singleton(); return instance; Test类： public class Test public static void main(String[] args) throws Exception //获取Singleton类的字节码对象 Class clazz = Singleton.class; //获取Singleton类的私有无参构造方法对象 Constructor constructor = clazz.getDeclaredConstructor(); //取消访问检查 constructor.setAccessible(true);​ //创建Singleton类的对象s1 Singleton s1 = (Singleton) constructor.newInstance(); //创建Singleton类的对象s2 Singleton s2 = (Singleton) constructor.newInstance();​ //判断通过反射创建的两个Singleton对象是否是同一个对象 System.out.println(s1 == s2); 说明反射通过 setAccessible(true) 把 private 构造方法“撬开”，再绕过 JVM 的访问检查直接 new 实例，因此完全无视你写的单例逻辑。上面代码运行结果是false，表明序列化和反序列化已经破坏了单例设计模式 注意：枚举方式实现的单例模式不会出现这两个问题。 如何解决破坏单例的问题在Singleton类中添加readResolve()方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。 序列化、反序列方式破坏单例模式的解决方法在Singleton类中添加readResolve()方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。Singleton类： public class Singleton implements Serializable ​ //私有构造方法 private Singleton() ​ private static class SingletonHolder private static final Singleton INSTANCE = new Singleton(); ​ //对外提供静态方法获取该对象 public static Singleton getInstance() return SingletonHolder.INSTANCE; /** * 下面是为了解决序列化反序列化破解单例模式 */ private Object readResolve() return SingletonHolder.INSTANCE; 源码解析：ObjectInputStream类： public final Object readObject() throws IOException, ClassNotFoundException ... // if nested read, passHandle contains handle of enclosing object int outerHandle = passHandle; try Object obj = readObject0(false);//重点查看readObject0方法 ..... private Object readObject0(boolean unshared) throws IOException ... try switch (tc) ... case TC_OBJECT: return checkResolve(readOrdinaryObject(unshared));//重点查看readOrdinaryObject方法 ... finally depth--; bin.setBlockDataMode(oldMode); private Object readOrdinaryObject(boolean unshared) throws IOException ... //isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类， obj = desc.isInstantiable() ? desc.newInstance() : null; ... // 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true if (obj != null handles.lookupException(passHandle) == null desc.hasReadResolveMethod()) // 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量 // 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。 Object rep = desc.invokeReadResolve(obj); ... return obj; 数据流向：readObject() → readObject0() → readOrdinaryObject() 目的是把磁盘里的字节流还原成 Java 对象。 desc.isInstantiable() ? desc.newInstance() : null; desc 是类描述符（ObjectStreamClass）。 isInstantiable() 只要你的类不是 enum 且有无参构造就返回 true。 newInstance() 通过反射 Constructor.newInstance() 强行 new 一个新对象，完全绕过构造方法里的单例检查。 这一步就解释了为什么不加 readResolve() 时单例会被破坏——每次反序列化都 new 一个。 desc.hasReadResolveMethod() 如果你在类里写了readResolve(),这里就会返回 true。 小结Java 反序列化时，如果目标类里写了 readResolve()，就先用反射“new”出一个新实例，再立刻调用你的 readResolve() 把那个新实例“掉包”成你指定的单例，最后把单例返回给使用者。 反射方式破解单例的解决方法public class Singleton ​ //私有构造方法 private Singleton() /* 反射破解单例模式需要添加的代码 */ if(instance != null) // 第一次反射进来时 instance 为 null，拦不住； // 但第二次反射再进来时 instance 已非 null，可抛出异常阻止 throw new RuntimeException(); private static volatile Singleton instance;​ //对外提供静态方法获取该对象 public static Singleton getInstance() ​ // if(instance != null) return instance; ​ synchronized (Singleton.class) if(instance != null) return instance; instance = new Singleton(); return instance; 说明这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操作。 注意：这种写法只能挡第二次及以后的反射；完全杜绝还是得用枚举。 工厂模式假设设计一个咖啡店点餐系统设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。 具体类的设计如下： 概念在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：解耦。结构本章中会介绍三种工厂的使用： 简单工厂模式（不属于GOF的23种经典设计模式） 工厂方法模式 抽象工厂模式 简单工厂模式简单工厂不是一种设计模式，反而比较像是一种编程习惯。 简单工厂包含如下角色： 具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。 抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。 具体产品 ：实现或者继承抽象产品的子类 现在使用简单工厂对上面案例进行改进，类图如下： 工厂类代码如下： public class SimpleCoffeeFactory ​ public Coffee createCoffee(String type) Coffee coffee = null; if(americano.equals(type)) coffee = new AmericanoCoffee(); else if(latte.equals(type)) coffee = new LatteCoffee(); return coffee; 工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。 后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。 优缺点优点封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。缺点增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。 静态工厂模式在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下： public class SimpleCoffeeFactory ​ public static Coffee createCoffee(String type) Coffee coffee = null; if(americano.equals(type)) coffee = new AmericanoCoffee(); else if(latte.equals(type)) coffee = new LatteCoffee(); return coffe; 工厂方法模式针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。概念定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。结构工厂方法模式的主要角色： 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。实现代码如下：抽象工厂: public interface CoffeeFactory ​ Coffee createCoffee(); 具体工厂： public class LatteCoffeeFactory implements CoffeeFactory public Coffee createCoffee() return new LatteCoffee(); ​public class AmericanCoffeeFactory implements CoffeeFactory ​ public Coffee createCoffee() return new AmericanCoffee(); 咖啡店类： public class CoffeeStore ​ private CoffeeFactory factory;​ public CoffeeStore(CoffeeFactory factory) this.factory = factory; ​ public Coffee orderCoffee(String type) Coffee coffee = factory.createCoffee(); coffee.addMilk(); coffee.addsugar(); return coffee; 从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。 工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。 优缺点优点： 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程； 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；缺点： 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。 抽象工厂模式前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机等。这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。 概念抽象工厂模式是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。 结构抽象工厂模式的主要角色如下： 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。 实现现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：代码如下：抽象工厂类： public interface DessertFactory ​ Coffee createCoffee();​ Dessert createDessert(); 具体工厂类： //美式甜点工厂public class AmericanDessertFactory implements DessertFactory ​ public Coffee createCoffee() return new AmericanCoffee(); ​ public Dessert createDessert() return new MatchaMousse(); //意大利风味甜点工厂public class ItalyDessertFactory implements DessertFactory ​ public Coffee createCoffee() return new LatteCoffee(); ​ public Dessert createDessert() return new Tiramisu(); 优缺点优点当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。缺点当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。使用场景当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。 模式扩展简单工厂+配置文件解除耦合可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。第一步：定义配置文件为了演示方便，我们使用properties文件作为配置文件，名称为bean.properties american=com.itheima.pattern.factory.config_factory.AmericanCoffeelatte=com.itheima.pattern.factory.config_factory.LatteCoffee 第二步：改进工厂类 public class CoffeeFactory ​ private static MapString, Coffee map = new HashMap();​ static Properties p = new Properties(); InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(bean.properties); try p.load(is); //遍历Properties集合对象 SetObject keys = p.keySet(); for (Object key : keys) //根据键获取值（全类名） String className = p.getProperty((String) key); //获取字节码对象 Class clazz = Class.forName(className); Coffee obj = (Coffee) clazz.newInstance(); map.put((String)key,obj); catch (Exception e) e.printStackTrace(); ​ public static Coffee createCoffee(String name) ​ return map.get(name); 静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。 源码解析-Collection.Iterator方法public class Demo public static void main(String[] args) ListString list = new ArrayList(); list.add(1); list.add(2); list.add(2);​ //获取迭代器对象 IteratorString it = list.iterator(); //使用迭代器遍历 while(it.hasNext()) String ele = it.next(); System.out.println(ele); 使用迭代器遍历集合，获取集合中的元素。而单列集合获取迭代器的方法就使用到了工厂方法模式。我们看通过类图看看结构：Collection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。在具体的工厂类中iterator()方法创建具体的商品类的对象。 原型模式概述所谓原型模式，即：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。使用场景原型模式适用于需要频繁创建相似对象的场景，通过克隆可以节省资源并保持对象状态的一致性。结构原型模式包含如下角色： 抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。 访问类：使用具体原型类中的 clone() 方法来复制新的对象。接口类图如下 原型模式实现原型模式的克隆分为浅克隆和深克隆。 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。Java中的Object类中提供了 clone() 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。代码如下： RealizeType(具体实现的原型类) public class Realizetype implements Cloneable ​ public Realizetype() System.out.println(具体的原型对象创建完成！); ​ @Override protected Realizetype clone() throws CloneNotSupportedException System.out.println(具体原型复制成功！); return (Realizetype) super.clone(); PrototypeTest(测试访问类) public class PrototypeTest public static void main(String[] args) throws CloneNotSupportedException Realizetype r1 = new Realizetype(); Realizetype r2 = r1.clone();​ System.out.println(对象r1和r2是同一个对象？ + (r1 == r2)); 输出结果是false，表明这个r1和r2不是同一个对象，并且只有在r1创建时Realizetype的构造方法执行了一次，调用clone方法时并不会触发构造方法，而是触发实现的clone方法。 原型模式生成三好学生同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。类图如下：代码实现： //奖状类public class Citation implements Cloneable private String name;​ public void setName(String name) this.name = name; ​ public String getName() return (this.name); ​ public void show() System.out.println(name + 同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！); ​ @Override public Citation clone() throws CloneNotSupportedException return (Citation) super.clone(); ​//测试访问类public class CitationTest public static void main(String[] args) throws CloneNotSupportedException Citation c1 = new Citation(); c1.setName(张三);​ //复制奖状 Citation c2 = c1.clone(); //将奖状的名字修改李四 c2.setName(李四);​ c1.show(); c2.show(); 我们会发现，在调用c1.show();打印的学生是张三，调用c2.show();打印的学生是李四，成功实现了克隆后属性的修改。 原型模式应用场景 对象的创建非常复杂，可以使用原型模式快捷的创建对象。 性能和安全要求比较高。 原型模式扩展（深克隆）将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下： //奖状类public class Citation implements Cloneable private Student stu;​ public Student getStu() return stu; ​ public void setStu(Student stu) this.stu = stu; ​ void show() System.out.println(stu.getName() + 同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！); ​ @Override public Citation clone() throws CloneNotSupportedException return (Citation) super.clone(); ​//学生类public class Student private String name; private String address;​ public Student(String name, String address) this.name = name; this.address = address; ​ public Student() ​ public String getName() return name; ​ public void setName(String name) this.name = name; ​ public String getAddress() return address; ​ public void setAddress(String address) this.address = address; ​//测试类public class CitationTest public static void main(String[] args) throws CloneNotSupportedException ​ Citation c1 = new Citation(); Student stu = new Student(张三, 西安); c1.setStu(stu);​ //复制奖状 Citation c2 = c1.clone(); //获取c2奖状所属学生对象 Student stu1 = c2.getStu(); stu1.setName(李四);​ //判断stu对象和stu1对象是否是同一个对象 System.out.println(stu和stu1是同一个对象？ + (stu == stu1));​ c1.show(); c2.show(); 从运行结果中，我们可以得知stu和stu1是同一个对象，也就是说，浅拷贝不会针对非基本类型进行拷贝，只会仍指向原有属性所指向的对象的内存地址。stu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，而进行深克隆需要使用对象流。代码如下： public class CitationTest1 public static void main(String[] args) throws Exception Citation c1 = new Citation(); Student stu = new Student(张三, 西安); c1.setStu(stu);​ //创建对象输出流对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt)); //将c1对象写出到文件中 oos.writeObject(c1); oos.close();​ //创建对象出入流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt)); //读取对象 Citation c2 = (Citation) ois.readObject(); //获取c2奖状所属学生对象 Student stu1 = c2.getStu(); stu1.setName(李四);​ //判断stu对象和stu1对象是否是同一个对象 System.out.println(stu和stu1是同一个对象？ + (stu == stu1));​ c1.show(); c2.show(); 通过上面的结果，我们可以看出，stu和stu1不是同一个对象，实现了深克隆。通过序列化写入实现地址的深拷贝 注意：Citation类和Student类必须实现Serializable接口，否则会抛NotSerializableException异常。 建造者模式所谓建造者模式，即：将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。1）分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程 复杂的情况。2）由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。3）建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。 建造者模式结构建造者（Builder）模式包含如下角色： 抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。 具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。 产品类（Product）：要创建的复杂对象。 指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。类图如下： 建造者模式实例生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和OfoBuilder是具体的建造者；Director是指挥者。类图如下： //自行车类public class Bike private String frame; private String seat;​ public String getFrame() return frame; ​ public void setFrame(String frame) this.frame = frame; ​ public String getSeat() return seat; ​ public void setSeat(String seat) this.seat = seat; ​// 抽象 builder 类public abstract class Builder ​ protected Bike mBike = new Bike();​ public abstract void buildFrame(); public abstract void buildSeat(); public abstract Bike createBike();​//摩拜单车Builder类public class MobikeBuilder extends Builder ​ @Override public void buildFrame() mBike.setFrame(铝合金车架); ​ @Override public void buildSeat() mBike.setSeat(真皮车座); ​ @Override public Bike createBike() return mBike; ​//ofo单车Builder类public class OfoBuilder extends Builder ​ @Override public void buildFrame() mBike.setFrame(碳纤维车架); ​ @Override public void buildSeat() mBike.setSeat(橡胶车座); ​ @Override public Bike createBike() return mBike; ​//指挥者类public class Director private Builder mBuilder;​ public Director(Builder builder) mBuilder = builder; ​ public Bike construct() mBuilder.buildFrame(); mBuilder.buildSeat(); return mBuilder.createBike(); ​//测试类public class Client public static void main(String[] args) showBike(new OfoBuilder()); showBike(new MobikeBuilder()); private static void showBike(Builder builder) Director director = new Director(builder); Bike bike = director.construct(); System.out.println(bike.getFrame()); System.out.println(bike.getSeat()); 注意上面示例是 Builder模式的常规用法，指挥者类 Director 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合。 // 抽象 builder 类public abstract class Builder ​ protected Bike mBike = new Bike();​ public abstract void buildFrame(); public abstract void buildSeat(); public abstract Bike createBike(); public Bike construct() this.buildFrame(); this.BuildSeat(); return this.createBike(); 这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中。 建造者模式优缺点优点1）建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。 2）在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 3）建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。缺点造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。 建造者模式的使用场景建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。1）创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。2）创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。 建造者模式扩展建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。(参数多进行重构) public class Phone private String cpu; private String screen; private String memory; private String mainboard;​ public Phone(String cpu, String screen, String memory, String mainboard) this.cpu = cpu; this.screen = screen; this.memory = memory; this.mainboard = mainboard; ​ public String getCpu() return cpu; ​ public void setCpu(String cpu) this.cpu = cpu; ​ public String getScreen() return screen; ​ public void setScreen(String screen) this.screen = screen; ​ public String getMemory() return memory; ​ public void setMemory(String memory) this.memory = memory; ​ public String getMainboard() return mainboard; ​ public void setMainboard(String mainboard) this.mainboard = mainboard; ​ @Override public String toString() return Phone + cpu= + cpu + \\ + , screen= + screen + \\ + , memory= + memory + \\ + , mainboard= + mainboard + \\ + ; ​public class Client public static void main(String[] args) //构建Phone对象 Phone phone = new Phone(intel,三星屏幕,金士顿,华硕); System.out.println(phone); 上面在客户端代码中构建Phone对象，传递了四个参数，如果参数更多呢？代码的可读性及使用的成本就是比较高。 重构后代码： public class Phone ​ private String cpu; private String screen; private String memory; private String mainboard;​ private Phone(Builder builder) cpu = builder.cpu; screen = builder.screen; memory = builder.memory; mainboard = builder.mainboard; ​ public static final class Builder private String cpu; private String screen; private String memory; private String mainboard;​ public Builder() ​ public Builder cpu(String val) cpu = val; return this; public Builder screen(String val) screen = val; return this; public Builder memory(String val) memory = val; return this; public Builder mainboard(String val) mainboard = val; return this; public Phone build() return new Phone(this); @Override public String toString() return Phone + cpu= + cpu + \\ + , screen= + screen + \\ + , memory= + memory + \\ + , mainboard= + mainboard + \\ + ; ​public class Client public static void main(String[] args) Phone phone = new Phone.Builder() .cpu(intel) .mainboard(华硕) .memory(金士顿) .screen(三星) .build(); System.out.println(phone); 重构后的代码在使用起来更方便，可以实现链式调用，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。 创建者模式对比——工厂模式和建造者模式的区别经过前面的学习，我们知道创建者模式主要包括：单例模式、原型模式、工厂方法模式、抽象工厂模式和建造者模式，这里我们主要对比：工厂方法模式和建造者模式、抽象工厂模式和建造者模式。 工厂方法模式和建造者模式对比工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。 抽象工厂模式和建造者模式对比抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。因此，我们也可以将工厂模式和建造者模式进行结合使用，工厂模式负责生产实例，而建造者模式负责装配。 第三章 结构型模式结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。结构型模式详细教程如下： 代理模式概述由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。 结构代理（Proxy）模式分为三种角色： 抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。 真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。 代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。 静态代理如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：代码如下： //卖票接口public interface SellTickets void sell();​//火车站 火车站具有卖票功能，所以需要实现SellTickets接口public class TrainStation implements SellTickets ​ public void sell() System.out.println(火车站卖票); ​//代售点public class ProxyPoint implements SellTickets ​ private TrainStation station = new TrainStation();​ public void sell() System.out.println(代理点收取一些服务费用); station.sell(); ​//测试类public class Client public static void main(String[] args) ProxyPoint pp = new ProxyPoint(); pp.sell(); 从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。 JDK动态代理接下来我们使用动态代理实现上面案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。代码如下： //卖票接口public interface SellTickets void sell();​//火车站 火车站具有卖票功能，所以需要实现SellTickets接口public class TrainStation implements SellTickets ​ public void sell() System.out.println(火车站卖票); ​//代理工厂，用来创建代理对象public class ProxyFactory ​ private TrainStation station = new TrainStation();​ public SellTickets getProxyObject() //使用Proxy获取代理对象 /* newProxyInstance()方法参数说明： ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可 Class?[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口 InvocationHandler h ： 代理对象的调用处理程序 */ SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(), station.getClass().getInterfaces(), new InvocationHandler() /* InvocationHandler中invoke方法参数说明： proxy ： 代理对象 method ： 对应于在代理对象上调用的接口方法的 Method 实例 args ： 代理对象调用接口方法时传递的实际参数 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable ​ System.out.println(代理点收取一些服务费用(JDK动态代理方式)); //执行真实对象 Object result = method.invoke(station, args); return result; ); return sellTickets; ​//测试类public class Client public static void main(String[] args) //获取代理对象 ProxyFactory factory = new ProxyFactory(); SellTickets proxyObject = factory.getProxyObject(); proxyObject.sell(); 使用了动态代理，我们思考下面问题：ProxyFactory是代理类吗？ProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的Java 诊断工具（Arthas【阿尔萨斯】查看代理类的结构： package com.sun.proxy;​import com.itheima.proxy.dynamic.jdk.SellTickets;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;​public final class $Proxy0 extends Proxy implements SellTickets private static Method m1; private static Method m2; private static Method m3; private static Method m0;​ public $Proxy0(InvocationHandler invocationHandler) super(invocationHandler); ​ static try m1 = Class.forName(java.lang.Object).getMethod(equals, Class.forName(java.lang.Object)); m2 = Class.forName(java.lang.Object).getMethod(toString, new Class[0]); m3 = Class.forName(com.itheima.proxy.dynamic.jdk.SellTickets).getMethod(sell, new Class[0]); m0 = Class.forName(java.lang.Object).getMethod(hashCode, new Class[0]); return; catch (NoSuchMethodException noSuchMethodException) throw new NoSuchMethodError(noSuchMethodException.getMessage()); catch (ClassNotFoundException classNotFoundException) throw new NoClassDefFoundError(classNotFoundException.getMessage()); ​ public final boolean equals(Object object) try return (Boolean)this.h.invoke(this, m1, new Object[]object); catch (Error | RuntimeException throwable) throw throwable; catch (Throwable throwable) throw new UndeclaredThrowableException(throwable); ​ public final String toString() try return (String)this.h.invoke(this, m2, null); catch (Error | RuntimeException throwable) throw throwable; catch (Throwable throwable) throw new UndeclaredThrowableException(throwable); ​ public final int hashCode() try return (Integer)this.h.invoke(this, m0, null); catch (Error | RuntimeException throwable) throw throwable; catch (Throwable throwable) throw new UndeclaredThrowableException(throwable); ​ public final void sell() try this.h.invoke(this, m3, null); return; catch (Error | RuntimeException throwable) throw throwable; catch (Throwable throwable) throw new UndeclaredThrowableException(throwable); 从上面的类中，我们可以看到以下几个信息：1）代理类（$Proxy0）实现了SellTickets。这也就印证了我们之前说的真实类和代理类实现同样的接口。2）代理类（$Proxy0）将我们提供了的匿名内部类对象传递给了父类 动态代理的执行流程是什么样？下面是摘取的重点代码： //程序运行过程中动态生成的代理类public final class $Proxy0 extends Proxy implements SellTickets private static Method m3;​ public $Proxy0(InvocationHandler invocationHandler) super(invocationHandler); ​ static m3 = Class.forName(com.itheima.proxy.dynamic.jdk.SellTickets).getMethod(sell, new Class[0]); ​ public final void sell() this.h.invoke(this, m3, null); ​//Java提供的动态代理相关类public class Proxy implements java.io.Serializable protected InvocationHandler h; protected Proxy(InvocationHandler h) this.h = h; ​//代理工厂类public class ProxyFactory ​ private TrainStation station = new TrainStation();​ public SellTickets getProxyObject() SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(), station.getClass().getInterfaces(), new InvocationHandler() public Object invoke(Object proxy, Method method, Object[] args) throws Throwable ​ System.out.println(代理点收取一些服务费用(JDK动态代理方式)); Object result = method.invoke(station, args); return result; ); return sellTickets; ​​//测试访问类public class Client public static void main(String[] args) //获取代理对象 ProxyFactory factory = new ProxyFactory(); SellTickets proxyObject = factory.getProxyObject(); proxyObject.sell(); 执行流程如下：1）在测试类中通过代理对象调用sell()方法2）根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法3）代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法4）invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法 CGLIB动态代理同样是上面的案例，我们再次使用CGLIB代理实现。如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。 dependency groupIdcglib/groupId artifactIdcglib/artifactId version2.2.2/version/dependency 代码如下： //火车站public class TrainStation ​ public void sell() System.out.println(火车站卖票); ​//代理工厂public class ProxyFactory implements MethodInterceptor ​ private TrainStation target = new TrainStation();​ public TrainStation getProxyObject() //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数 Enhancer enhancer =new Enhancer(); //设置父类的字节码对象 enhancer.setSuperclass(target.getClass()); //设置回调函数 enhancer.setCallback(this); //创建代理对象 TrainStation obj = (TrainStation) enhancer.create(); return obj; ​ /* intercept方法参数说明： o ： 代理对象 method ： 真实对象中的方法的Method实例 args ： 实际参数 methodProxy ：代理对象中的方法的method实例 */ public TrainStation intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable System.out.println(代理点收取一些服务费用(CGLIB动态代理方式)); TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args); return result; ​//测试类public class Client public static void main(String[] args) //创建代理工厂对象 ProxyFactory factory = new ProxyFactory(); //获取代理对象 TrainStation proxyObject = factory.getProxyObject();​ proxyObject.sell(); 三种代理的对比jdk代理和CGLIB代理使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。 在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。 动态代理和静态代理动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。 如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题 代理模式优缺点优点：代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；代理对象可以扩展目标对象的功能；代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度； 缺点：增加了系统的复杂度； 代理模式应用场景远程代理本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。防火墙（Firewall）代理当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。保护（Protect or Access）代理控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。 适配器模式适配器模式概述如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。 适配器模式定义将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。 适配器模式结构适配器模式（Adapter）包含以下主要角色： 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者 类适配器模式实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。以读卡器为例现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。类图如下：代码如下： //SD卡的接口public interface SDCard //读取SD卡方法 String readSD(); //写入SD卡功能 void writeSD(String msg);​//SD卡实现类public class SDCardImpl implements SDCard public String readSD() String msg = sd card read a msg :hello word SD; return msg; ​ public void writeSD(String msg) System.out.println(sd card write msg : + msg); ​//电脑类public class Computer ​ public String readSD(SDCard sdCard) if(sdCard == null) throw new NullPointerException(sd card null); return sdCard.readSD(); ​//TF卡接口public interface TFCard //读取TF卡方法 String readTF(); //写入TF卡功能 void writeTF(String msg);​//TF卡实现类public class TFCardImpl implements TFCard ​ public String readTF() String msg =tf card read msg : hello word tf card; return msg; ​ public void writeTF(String msg) System.out.println(tf card write a msg : + msg); ​//定义适配器类（SD兼容TF）public class SDAdapterTF extends TFCardImpl implements SDCard ​ public String readSD() System.out.println(adapter read tf card ); return readTF(); ​ public void writeSD(String msg) System.out.println(adapter write tf card); writeTF(msg); ​//测试类public class Client public static void main(String[] args) Computer computer = new Computer(); SDCard sdCard = new SDCardImpl(); System.out.println(computer.readSD(sdCard));​ System.out.println(------------);​ SDAdapterTF adapter = new SDAdapterTF(); System.out.println(computer.readSD(adapter)); 类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。 对象适配器模式实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。以读卡器为例我们使用对象适配器模式将读卡器的案例进行改写。类图如下：代码如下：类适配器模式的代码，我们只需要修改适配器类（SDAdapterTF）和测试类。 //创建适配器对象（SD兼容TF）public class SDAdapterTF implements SDCard ​ private TFCard tfCard;​ public SDAdapterTF(TFCard tfCard) this.tfCard = tfCard; ​ public String readSD() System.out.println(adapter read tf card ); return tfCard.readTF(); ​ public void writeSD(String msg) System.out.println(adapter write tf card); tfCard.writeTF(msg); ​//测试类public class Client public static void main(String[] args) Computer computer = new Computer(); SDCard sdCard = new SDCardImpl(); System.out.println(computer.readSD(sdCard));​ System.out.println(------------);​ TFCard tfCard = new TFCardImpl(); SDAdapterTF adapter = new SDAdapterTF(tfCard); System.out.println(computer.readSD(adapter)); 注意：还有一个适配器模式是接口适配器模式。当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter ，实现所有方法。而此时我们只需要继承该抽象类即可。 适配器模式应用场景 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。 JDK源码应用适配器模式案例解析Reader（字符流）、InputStream（字节流）的适配使用的是InputStreamReader。InputStreamReader继承自java.io包中的Reader，对他中的抽象的未实现的方法给出实现。如： public int read() throws IOException return sd.read();​public int read(char cbuf[], int offset, int length) throws IOException return sd.read(cbuf, offset, length); 如上代码中的sd（StreamDecoder类对象），在Sun的JDK实现中，实际的方法实现是对sun.nio.cs.StreamDecoder类的同名方法的调用封装。类结构图如下： 从上图可以看出：InputStreamReader是对同样实现了Reader的StreamDecoder的封装。StreamDecoder不是Java SE API中的内容，是Sun JDK给出的自身实现。但我们知道他们对构造方法中的字节流类（InputStream）进行封装，并通过该类进行了字节流和字符流之间的解码转换。结论从表层来看，InputStreamReader做了InputStream字节流类到Reader字符流之间的转换。而从如上Sun JDK中的实现类关系结构中可以看出，是StreamDecoder的设计实现在实际上采用了适配器模式。 装饰者模式装饰者模式概述我们先来看一个快餐店的例子。快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。下图是传统方式实现该功能的类图，从图中发现这里多处使用了继承： 使用继承的方式存在的问题：1）扩展性不好如果要再加一种配料（火腿肠），我们就会发现需要给FriedRice和FriedNoodles分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。2）产生过多的子类，存在类爆炸可能 装饰者模式定义指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。 装饰者模式结构装饰（Decorator）模式中的角色： 抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。 具体构件（Concrete Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。 抽象装饰（Decorator）角色 ： 继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。 具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。 装饰者模式案例我们使用装饰者模式对快餐店案例进行改进，体会装饰者模式的精髓。类图如下：代码如下： //快餐接口public abstract class FastFood private float price; private String desc;​ public FastFood() ​ public FastFood(float price, String desc) this.price = price; this.desc = desc; ​ public void setPrice(float price) this.price = price; ​ public float getPrice() return price; ​ public String getDesc() return desc; ​ public void setDesc(String desc) this.desc = desc; ​ public abstract float cost(); //获取价格​//炒饭public class FriedRice extends FastFood ​ public FriedRice() super(10, 炒饭); ​ public float cost() return getPrice(); ​//炒面public class FriedNoodles extends FastFood ​ public FriedNoodles() super(12, 炒面); ​ public float cost() return getPrice(); ​//配料类public abstract class Garnish extends FastFood ​ private FastFood fastFood;​ public FastFood getFastFood() return fastFood; ​ public void setFastFood(FastFood fastFood) this.fastFood = fastFood; ​ public Garnish(FastFood fastFood, float price, String desc) super(price,desc); this.fastFood = fastFood; ​//鸡蛋配料public class Egg extends Garnish ​ public Egg(FastFood fastFood) super(fastFood,1,鸡蛋); ​ public float cost() return getPrice() + getFastFood().getPrice(); ​ @Override public String getDesc() return super.getDesc() + getFastFood().getDesc(); ​//培根配料public class Bacon extends Garnish ​ public Bacon(FastFood fastFood) ​ super(fastFood,2,培根); ​ @Override public float cost() return getPrice() + getFastFood().getPrice(); ​ @Override public String getDesc() return super.getDesc() + getFastFood().getDesc(); ​//测试类public class Client public static void main(String[] args) //点一份炒饭 FastFood food = new FriedRice(); //花费的价格 System.out.println(food.getDesc() + + food.cost() + 元);​ System.out.println(========); //点一份加鸡蛋的炒饭 FastFood food1 = new FriedRice();​ food1 = new Egg(food1); //花费的价格 System.out.println(food1.getDesc() + + food1.cost() + 元);​ System.out.println(========); //点一份加培根的炒面 FastFood food2 = new FriedNoodles(); food2 = new Bacon(food2); //花费的价格 System.out.println(food2.getDesc() + + food2.cost() + 元); 好处装饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 装饰者模式应用场景1、当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：1）第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；2）第二类是因为类定义不能继承（如final类） 2、在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。3、当对象的功能要求可以动态地添加，也可以再动态地撤销时。 JDK源码使用装饰者模式案例解析IO流中的包装类使用到了装饰者模式。BufferedInputStream，BufferedOutputStream，BufferedReader，BufferedWriter。 我们以BufferedWriter举例来说明，先看看如何使用BufferedWriter public class Demo public static void main(String[] args) throws Exception //创建BufferedWriter对象 //创建FileWriter对象 FileWriter fw = new FileWriter(C:\\\\Users\\\\Think\\\\Desktop\\\\a.txt); BufferedWriter bw = new BufferedWriter(fw);​ //写数据 bw.write(hello Buffered);​ bw.close(); 使用起来感觉确实像是装饰者模式，接下来看它们的结构： 小结BufferedWriter使用装饰者模式对Writer子实现类进行了增强，添加了缓冲区，提高了写数据的效率。 代理模式和装饰者模式的区别前面的教程我们已经学过了代理模式和装饰者模式，这两种模式存在一定的相似之处，也更主要的是不同点，我们在此总结如下（主要针对静态代理）： 静态代理和装饰者模式的区别：相同点： 都要实现与目标类相同的业务接口 在两个类中都要声明目标对象 都可以在不修改目标类的前提下增强目标方法 不同点： 目的不同 装饰者是为了增强目标对象 静态代理是为了保护和隐藏目标对象 获取目标对象构建的地方不同 装饰者是由外界传递进来，可以通过构造方法传递 静态代理是在代理类内部创建，以此来隐藏目标对象 桥接模式桥接模式概述现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系：我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。 试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。 桥接模式定义将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 桥接模式结构桥接（Bridge）模式包含以下主要角色： 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。 扩展抽象化（Refined Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。 具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。 桥接模式Java代码案例【例】视频播放器需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。 //视频文件（实现化角色）public interface VideoFile void decode(String fileName);​//avi文件（具体实现化角色 ）public class AVIFile implements VideoFile public void decode(String fileName) System.out.println(avi视频文件：+ fileName); ​//rmvb文件（具体实现化角色 ）public class REVBBFile implements VideoFile ​ public void decode(String fileName) System.out.println(rmvb文件： + fileName); ​//操作系统版本（抽象化角色）public abstract class OperatingSystemVersion ​ protected VideoFile videoFile;​ public OperatingSystemVersion(VideoFile videoFile) this.videoFile = videoFile; ​ public abstract void play(String fileName);​//Windows版本（扩展抽象化角色）public class Windows extends OperatingSystem ​ public Windows(VideoFile videoFile) super(videoFile); ​ public void play(String fileName) videoFile.decode(fileName); ​//mac版本（扩展抽象化角色）public class Mac extends OperatingSystemVersion ​ public Mac(VideoFile videoFile) super(videoFile); ​ public void play(String fileName) videoFile.decode(fileName); ​//测试类public class Client public static void main(String[] args) OperatingSystem os = new Windows(new AVIFile()); os.play(战狼3); 这样操作系统就可以和视频文件格式进行任意地组合，如果需要支持新的视频格式，只需要新建一个视频格式类实现VideoFile接口即可，新增操作系统类型，也只需新建一个操作系统类继承OperatingSystem 即可，两个维度扩展相互独立且简单灵活。 桥接模式好处1）桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。2）实现细节对客户透明 桥接模式应用场景 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 外观模式外观模式概述有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。 外观模式定义又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。外观（Facade）模式是“迪米特法则”的典型应用图中，左边为不适用外观模式的设计，有边为使用外观模式后的客户类和子系统的访问设计。 外观模式结构外观（Facade）模式包含以下主要角色： 外观（Facade）角色：为多个子系统对外提供一个共同的接口。 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。 外观模式Java实例【例】智能家电控制小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下：代码如下： //灯类public class Light public void on() System.out.println(打开了灯....); ​ public void off() System.out.println(关闭了灯....); ​//电视类public class TV public void on() System.out.println(打开了电视....); ​ public void off() System.out.println(关闭了电视....); ​//控制类public class AirCondition public void on() System.out.println(打开了空调....); ​ public void off() System.out.println(关闭了空调....); ​//智能音箱public class SmartAppliancesFacade ​ private Light light; private TV tv; private AirCondition airCondition;​ public SmartAppliancesFacade() light = new Light(); tv = new TV(); airCondition = new AirCondition(); ​ public void say(String message) if(message.contains(打开)) on(); else if(message.contains(关闭)) off(); else System.out.println(我还听不懂你说的！！！); ​ //起床后一键开电器 private void on() System.out.println(起床了); light.on(); tv.on(); airCondition.on(); ​ //睡觉一键关电器 private void off() System.out.println(睡觉了); light.off(); tv.off(); airCondition.off(); ​//测试类public class Client public static void main(String[] args) //创建外观对象 SmartAppliancesFacade facade = new SmartAppliancesFacade(); //客户端直接与外观对象进行交互 facade.say(打开家电); facade.say(关闭家电); 外观模式的优缺点优点：降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。缺点不符合开闭原则，修改很麻烦，比如新增一个子系统，可能就需要修改外观类中的代码。 外观模式使用场景 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。 外观模式应用源码解析使用tomcat作为web容器时，接收浏览器发送过来的请求，tomcat会将请求信息封装成ServletRequest对象，如下图①处对象。但是大家想想ServletRequest是一个接口，它还有一个子接口HttpServletRequest，而我们知道该request对象肯定是一个HttpServletRequest对象的子实现类对象，到底是哪个类的对象呢？可以通过输出request对象，我们就会发现是一个名为RequestFacade的类的对象。 RequestFacade类就使用了外观模式。先看结构图： 为什么在此处使用外观模式呢？定义 RequestFacade 类，分别实现 ServletRequest ，同时定义私有成员变量 Request ，并且方法的实现调用 Request 的实现。然后，将 RequestFacade上转为 ServletRequest 传给 servlet 的 service 方法，这样即使在 servlet 中被下转为 RequestFacade ，也不能访问私有成员变量对象中的方法。既用了 Request ，又能防止其中方法被不合理的访问。 组合模式组合模式定义组合模式，又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。 组合模式概述对于这个图片肯定会非常熟悉，上图我们可以看做是一个文件系统，对于这样的结构我们称之为树形结构。在树形结构中可以通过调用某个方法来遍历整个树，当我们找到某个叶子节点后，就可以对叶子节点进行相关的操作。可以将这颗树理解成一个大的容器，容器里面包含很多的成员对象，这些成员对象即可是容器对象也可以是叶子对象。但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须要区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦，作为客户而已，它始终希望能够一致的对待容器对象和叶子对象。 组合模式结构组合模式主要包含三种角色： 抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。 树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。 叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。 组合模式Java例子实现要实现该案例，我们先画出类图：代码实现：不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。 //菜单组件 不管是菜单还是菜单项，都应该继承该类（抽象根节点）public abstract class MenuComponent ​ protected String name; protected int level;​ //添加菜单 public void add(MenuComponent menuComponent) throw new UnsupportedOperationException(); ​ //移除菜单 public void remove(MenuComponent menuComponent) throw new UnsupportedOperationException(); ​ //获取指定的子菜单 public MenuComponent getChild(int i) throw new UnsupportedOperationException(); ​ //获取菜单名称 public String getName() return name; ​ public void print() throw new UnsupportedOperationException(); 这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现，Menu和MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。这里给出的默认实现是抛出异常，你也可以根据自己的需要改写默认实现。 // 子菜单项（树枝节点）public class Menu extends MenuComponent ​ private ListMenuComponent menuComponentList;​ public Menu(String name,int level) this.level = level; this.name = name; menuComponentList = new ArrayListMenuComponent(); ​ @Override public void add(MenuComponent menuComponent) menuComponentList.add(menuComponent); ​ @Override public void remove(MenuComponent menuComponent) menuComponentList.remove(menuComponent); ​ @Override public MenuComponent getChild(int i) return menuComponentList.get(i); ​ @Override public void print() ​ // 方便打印出层级效果 for (int i = 1; i level; i++) System.out.print(--); System.out.println(name); for (MenuComponent menuComponent : menuComponentList) menuComponent.print(); Menu类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。 // 子菜单（叶子节点）public class MenuItem extends MenuComponent ​ public MenuItem(String name,int level) this.name = name; this.level = level; ​ @Override public void print() // 方便打印出层级效果 for (int i = 1; i level; i++) System.out.print(--); System.out.println(name); MenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。 组合模式的分类在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。 透明组合模式透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 MenuComponent 声明了 add、remove 、getChild 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码） 安全组合模式在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 Menu 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。组合模式优点 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。 在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。 组合模式的应用场景组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。 享元模式享元模式定义运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。 享元模式结构享元（Flyweight ）模式中存在以下两种状态： 内部状态：即不会随着环境的改变而改变的可共享部分。 外部状态：指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。 享元模式的主要有以下角色： 抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。 具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。 非享元（Unsharable Flyweight）角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。 享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。 享元模式Java实例【例】俄罗斯方块下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。先来看采用享元模式设计的类图： 代码如下：俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。 // 抽象享元角色public abstract class AbstractBox //获取图形的方法 public abstract String getShape();​ //显示图形及颜色 public void display(String color) System.out.println(方块形状： + this.getShape() + 颜色： + color); 接下来就是定义不同的形状了，IBox类、LBox类、OBox类等。 // 这3个都是具体享元角色public class IBox extends AbstractBox ​ @Override public String getShape() return I; ​public class LBox extends AbstractBox ​ @Override public String getShape() return L; ​public class OBox extends AbstractBox ​ @Override public String getShape() return O; 提供了一个工厂类（BoxFactory），用来管理享元对象（也就是AbstractBox子类对象），该工厂类对象只需要一个，所以可以使用单例模式。并给工厂类提供一个获取形状的方法。 // 享元工厂角色，这里采用的是饿汉式单例public class BoxFactory ​ //享元池 private static HashMapString, AbstractBox map;​ //在构造方法中进行初始化操作 private BoxFactory() map = new HashMapString, AbstractBox(); AbstractBox iBox = new IBox(); AbstractBox lBox = new LBox(); AbstractBox oBox = new OBox(); map.put(I, iBox); map.put(L, lBox); map.put(O, oBox); ​//提供一个方法获取该工厂类对象 public static final BoxFactory getInstance() return SingletonHolder.INSTANCE; ​ private static class SingletonHolder private static final BoxFactory INSTANCE = new BoxFactory(); ​//根据名称获取图形对象 public AbstractBox getBox(String key) return map.get(key); 最后，我们提供测试类，进行测试享元模式效果： // 享元工厂角色，这里采用的是饿汉式单例public class BoxFactory ​ //享元池 private static HashMapString, AbstractBox map;​ //在构造方法中进行初始化操作 private BoxFactory() map = new HashMapString, AbstractBox(); AbstractBox iBox = new IBox(); AbstractBox lBox = new LBox(); AbstractBox oBox = new OBox(); map.put(I, iBox); map.put(L, lBox); map.put(O, oBox); ​//提供一个方法获取该工厂类对象 public static final BoxFactory getInstance() return SingletonHolder.INSTANCE; ​ private static class SingletonHolder private static final BoxFactory INSTANCE = new BoxFactory(); ​//根据名称获取图形对象 public AbstractBox getBox(String key) return map.get(key); 最后，我们提供测试类，进行测试享元模式效果： public class Client public static void main(String[] args) //获取I图形对象 AbstractBox box1 = BoxFactory.getInstance().getShape(I); box1.display(灰色); //获取L图形对象 AbstractBox box2 = BoxFactory.getInstance().getShape(L); box2.display(绿色); //获取O图形对象 AbstractBox box3 = BoxFactory.getInstance().getShape(O); box3.display(灰色); //获取O图形对象 AbstractBox box4 = BoxFactory.getInstance().getShape(O); box4.display(红色); System.out.println(两次获取到的O图形对象是否是同一个对象： + (box3 == box4)); 运行测试类，结果如下： 享元模式优缺点和使用场景优点 极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能 享元模式中的外部状态相对独立，且不影响内部状态 缺点为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂 享元模式使用场景 一个系统有大量相同或者相似的对象，造成内存的大量耗费。 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。 JDK源码应用享元模式解析Integer类使用了享元模式。我们先看下面的例子： public class Demo public static void main(String[] args) Integer i1 = 127; Integer i2 = 127;​ System.out.println(i1和i2对象是否是同一个对象？ + (i1 == i2));​ Integer i3 = 128; Integer i4 = 128;​ System.out.println(i3和i4对象是否是同一个对象？ + (i3 == i4)); 运行上面代码，结果如下： i1和i2对象是否是同一个对象？truei3和i4对象是否是同一个对象？false 为什么第一个输出语句输出的是true，第二个输出语句输出的是false？通过反编译软件进行反编译，代码如下： public class Demo public static void main(String[] args) Integer i1 = Integer.valueOf((int)127); Integer i2 Integer.valueOf((int)127); System.out.println((String)new StringBuilder().append((String)i1\\u548ci2\\u5bf9\\u8c61\\u662f\\u5426\\u662f\\u540c\\u4e00\\u4e2a\\u5bf9\\u8c61\\uff1f).append((boolean)(i1 == i2)).toString()); Integer i3 = Integer.valueOf((int)128); Integer i4 = Integer.valueOf((int)128); System.out.println((String)new StringBuilder().append((String)i3\\u548ci4\\u5bf9\\u8c61\\u662f\\u5426\\u662f\\u540c\\u4e00\\u4e2a\\u5bf9\\u8c61\\uff1f).append((boolean)(i3 == i4)).toString()); 上面代码可以看到，直接给Integer类型的变量赋值基本数据类型数据的操作底层使用的是 valueOf() ，所以只需要看该方法即可： public final class Integer extends Number implements ComparableInteger public static Integer valueOf(int i) if (i = IntegerCache.low i = IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); private static class IntegerCache static final int low = -128; static final int high; static final Integer cache[];​ static int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(java.lang.Integer.IntegerCache.high); if (integerCacheHighPropValue != null) try int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); catch( NumberFormatException nfe) high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high = 127; ​ private IntegerCache() 可以看到 Integer 默认先创建并缓存 -128 ~ 127 之间数的 Integer 对象，当调用 valueOf 时如果参数在 -128 ~ 127 之间则计算下标并从缓存中返回，否则创建一个新的 Integer 对象。 第四章 行为型模式","tags":["Java基础","设计开发"],"categories":["Java","设计开发"]}]